<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="robots" content="noindex, nofollow">
    <title>Floresta MÃ­stica - Aden RPG</title>
    <script src="maintenance.js"></script>
    <link rel="stylesheet" href="style.css" />
</head>
<style>
.goog-te-banner-frame.skiptranslate,.skiptranslate{display:none!important;visibility:hidden!important;height:0!important;}
body{top:0!important;margin-top:0!important;position:static!important;}
.goog-te-balloon-frame,.goog-te-gadget{display:none!important;height:0!important;overflow:hidden!important;}
font>font{background-color:transparent!important;box-shadow:none!important;position:static!important;}
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
body,p,span,div,button,label{font-family:'Cinzel',serif;}
h1,h2,h3{font-family:'Cinzel',serif;color:#e0dccc;text-shadow:2px 2px 4px #000;}
html,body{height:100%;margin:0;padding:0;box-sizing:border-box;}
body{display:flex;flex-direction:column;align-items:center;background:#121212;min-height:100vh;overflow-x:hidden;}

#playerTopBar{position:fixed;top:0;left:0;width:100%;height:50px;background:#1a1a1a;color:#fff;display:flex;justify-content:space-between;align-items:center;padding:0 12px;box-shadow:0 2px 8px rgba(0,0,0,.7);z-index:1000;box-sizing:border-box;}
.top-bar-link{color:#fff;text-decoration:none;display:flex;align-items:center;}
#pageTitle{color:#ffb3b3;font-size:1.2em;font-weight:bold;text-shadow:1px 1px 2px #000;}

#mapContainer{position:fixed;top:0;left:0;width:100vw;height:100vh;overflow:hidden;z-index:1;background:#0d1a0d;}
#map{background-image:url('https://aden-rpg.pages.dev/assets/floresta_mistica.webp');background-size:contain;background-repeat:no-repeat;background-position:top left;width:1500px;height:1500px;position:absolute;cursor:grab;transform-origin:top left;transform:scale(1.1);user-select:none;}

.hunt-spot{position:absolute;border:2px dashed transparent;
/*border:2px dashed #0f0;*/
border-radius:8px;cursor:default;overflow:visible;z-index:5;}
.hunt-spot:hover,.hunt-spot:focus,.hunt-spot:active{border-color:transparent;outline:none;}
.spot-label{position:absolute;bottom:-20px;left:50%;transform:translateX(-50%);color:rgba(255,255,255,.65);font-size:.6em;font-weight:bold;text-shadow:1px 1px 3px #000;white-space:nowrap;pointer-events:none;}
.hunt-spot.active-spot{cursor:default!important;}

.mob-wrapper{position:absolute;display:flex;flex-direction:column;align-items:center;gap:2px;z-index:6;pointer-events:none;}
.mob-name{font-size:.55em;font-weight:bold;text-shadow:1px 1px 2px #000;white-space:nowrap;}
.mob-avatar{width:60px;height:60px;border-radius:50%;border:3px solid #c00;object-fit:cover;background:#222;}

.player-avatar-wrapper{position:absolute;display:flex;flex-direction:column;align-items:center;gap:2px;z-index:10;pointer-events:none;}
.player-shield-icon{width:30px;height:30px;object-fit:contain;}
.player-name-label{font-size:0.75em;font-weight:bold;color:#ff8;text-shadow:1px 1px 2px #000;white-space:nowrap;}
.player-spot-avatar{width:60px;height:60px;border-radius:50%;border:3px solid #fc0;object-fit:cover;background:#222;}

.other-player-wrapper{position:absolute;display:flex;flex-direction:column;align-items:center;gap:2px;z-index:9;cursor:pointer;}
.other-player-shield{width:30px;height:30px;object-fit:contain;}
.other-player-name{font-size:0.75em;font-weight:bold;color:#8cf;text-shadow:1px 1px 2px #000;white-space:nowrap;}
.other-player-avatar{width:60px;height:60px;border-radius:50%;border:3px solid #48f;object-fit:cover;background:#222;transition:filter .3s;}
.other-player-avatar.eliminated{filter:grayscale(100%) brightness(.6);}
.other-eliminated-label{font-size:.55em;color:#f44;font-weight:bold;text-shadow:1px 1px 2px #000;}

#contentOverlay{position:fixed;top:50px;left:0;width:100%;display:flex;flex-direction:column;align-items:center;z-index:10;pointer-events:none;}
#huntingHud{display:none;flex-direction:column;align-items:center;gap:5px;background:rgba(8,18,8,.9);border:1px solid #3a6c3a;border-radius:0 0 12px 12px;padding:8px 24px 12px;pointer-events:auto;min-width:240px;box-shadow:0 4px 16px rgba(0,0,0,.6);}
#huntTimer {
  font-size:1.9em;
  font-weight:bold;
  text-shadow: none;
  background: linear-gradient(to bottom, lightblue 0%, white 50%, blue 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent; 0 12px #4f4,1px 1px 2px #000;
  letter-spacing:3px;
  
}
#huntStatus{font-size:.7em;color:#b8d4b8;}
#shieldHudRow{display:flex;align-items:center;gap:8px;font-size:.7em;color:#acf;}
#shieldHudRow img{width:22px;height:22px;}
#hudBtnRow{display:flex;gap:8px;margin-top:2px;}
.hud-btn{background:rgba(255,255,255,.06);border:1px solid #455;color:#aca;padding:5px 14px;border-radius:5px;cursor:pointer;font-family:'Cinzel',serif;font-size:.65em;font-weight:bold;}
.hud-btn:hover{background:rgba(255,255,255,.14);color:#efe;}
.hud-btn:disabled{opacity:.4;cursor:not-allowed;}

#loadingOverlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);z-index:3000;justify-content:center;align-items:center;}
.loading-spinner{border:4px solid #2a3a2a;border-top:4px solid #8f8;border-radius:50%;width:50px;height:50px;animation:spin .8s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}

.modal-container{display:none;position:fixed;z-index:9000;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.88);justify-content:center;align-items:center;}
.modal-content{background:#1b271b;padding:22px;border:2px solid #4a8c4a;border-radius:10px;width:92%;max-width:460px;position:relative;max-height:90vh;box-sizing:border-box;text-align:center;overflow-y:auto;}
.modal-content h2,.modal-content h3{margin-top:0;color:#afa;text-shadow:0 0 8px #4f4,1px 1px 2px #000;font-size:1.05em;}
.modal-content p{color:#cdc;font-size:.85em;line-height:1.6;}
.modal-close{color:#787;position:absolute;top:8px;right:14px;font-size:26px;font-weight:bold;cursor:pointer;line-height:1;}
.modal-close:hover{color:#afa;}
.modal-btn-row{display:flex;gap:12px;justify-content:center;margin-top:14px;}
.modal-btn{background-image:url('https://aden-rpg.pages.dev/assets/botao.webp');background-size:cover;background-position:center;background-color:transparent;border:none;color:#e0dccc;font-weight:bold;font-family:'Cinzel',serif;padding:12px 22px;cursor:pointer;font-size:.9em;text-shadow:1px 1px 2px #000;min-width:90px;}
.modal-btn:hover{opacity:.9;}

#pvpModal .modal-content{max-width:520px;background:#160f22;border-color:#74b;}
#pvpModal h2{color:#daf;text-shadow:0 0 8px #a4f;}
.pvp-arena{display:flex;justify-content:space-around;align-items:flex-start;gap:10px;margin:12px 0;}
.pvp-fighter{display:flex;flex-direction:column;align-items:center;gap:6px;flex:1;max-width:160px;}
.pvp-fighter-name{font-size:.7em;color:#ddd;font-weight:bold;}
.pvp-fighter img{width:70px;height:70px;border-radius:50%;border:3px solid #85a;object-fit:cover;background:#222;}
.pvp-vs{font-size:1.6em;color:#fa4;align-self:center;font-weight:bold;text-shadow:0 0 10px #f60;}
.pvp-hp-bg{width:100%;height:14px;background:#333;border-radius:7px;overflow:hidden;}
.pvp-hp-fill{height:100%;background:linear-gradient(90deg,#c24,#f46);border-radius:7px;transition:width .3s;}
.pvp-hp-txt{font-size:.6em;color:#ccc;}
#pvpCountdown{font-size:.95em;color:#fd8;margin:6px 0;font-weight:bold;}

/* â”€â”€ DAMAGE NUMBERS (estilo mina) â”€â”€â”€ */
.damage-number{font-family:Georgia,serif;font-size:23px;font-weight:bold;color:#fff;text-shadow:2px 2px 4px #000;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:10;white-space:nowrap;animation:floating-damage 1.5s ease-out forwards;}
.crit-damage-number{font-family:Georgia,serif;font-size:2.1em;color:red;text-shadow:-1px -1px 0 yellow,1px -1px 0 yellow,-1px 1px 0 yellow,1px 1px 0 yellow,-2px -2px 0 yellow,2px -2px 0 yellow,-2px 2px 0 yellow,2px 2px 0 yellow;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:10;white-space:nowrap;animation:floating-damage-crit 1.5s ease-out forwards;}
.evade-text{font-size:1.4em;color:white;font-weight:bold;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:10;white-space:nowrap;text-shadow:1px 1px 2px #000,-1px -1px 2px #000;animation:floating-damage 2s ease-out forwards;}
@keyframes floating-damage{0%{opacity:1;transform:translate(-50%,-50%) scale(1);}100%{opacity:0;transform:translate(-50%,-150%) scale(1.3);}}
@keyframes floating-damage-crit{0%{opacity:1;transform:translate(-50%,-50%) scale(1);}50%{transform:translate(-50%,-80%) scale(1.4);}100%{opacity:0;transform:translate(-50%,-160%) scale(1.2);}}
@keyframes shake{0%,100%{transform:translateX(0)}20%{transform:translateX(-8px) rotate(-3deg)}40%{transform:translateX(8px) rotate(3deg)}60%{transform:translateX(-5px)}80%{transform:translateX(5px)}}
.shake-animation{animation:shake .35s cubic-bezier(.36,.07,.19,.97) both!important;backface-visibility:hidden;}

/* â”€â”€ MOB COMBAT ANIMATIONS â”€â”€â”€ */
@keyframes mob-death-fade{0%{opacity:1;transform:scale(1);}60%{opacity:.3;transform:scale(0.7) translateY(8px);}100%{opacity:0;transform:scale(0.4) translateY(18px);}}
@keyframes mob-respawn{0%{opacity:0;transform:scale(0.3) translateY(-14px);}60%{opacity:.9;transform:scale(1.12) translateY(-3px);}100%{opacity:1;transform:scale(1) translateY(0);}}
@keyframes player-lunge{0%{transform:scale(1);}40%{transform:scale(1.18) rotate(-6deg);}70%{transform:scale(1.08) rotate(3deg);}100%{transform:scale(1) rotate(0deg);}}
@keyframes mob-impact-flash{0%,100%{filter:brightness(1);}35%{filter:brightness(2.4) saturate(0.2);}}
.mob-dying .mob-avatar{animation:mob-death-fade 0.85s ease-out forwards!important;}
.mob-dying .mob-name{animation:mob-death-fade 0.65s ease-out forwards!important;}
.mob-respawning .mob-avatar{animation:mob-respawn 0.7s cubic-bezier(.22,1,.36,1) forwards!important;}
.mob-respawning .mob-name{animation:mob-respawn 0.55s cubic-bezier(.22,1,.36,1) forwards!important;}
.player-lunging .player-spot-avatar,.player-lunging .other-player-avatar{animation:player-lunge 0.45s ease-out!important;}
.mob-impact-flash .mob-avatar{animation:mob-impact-flash 0.28s ease-out!important;}

/* â”€â”€ KILL BANNER â”€â”€â”€ */
#huntKillBanner{position:fixed;top:58px;right:0;background:linear-gradient(90deg,rgba(180,30,0,.92),rgba(180,80,0,.92));color:#fff;padding:9px 22px;border-radius:6px 0 0 6px;z-index:25000;font-weight:bold;white-space:nowrap;text-shadow:1px 1px 2px #000;box-shadow:0 0 12px rgba(0,0,0,.6);opacity:0;transform:translateX(100%);transition:opacity .3s;}
#huntKillBanner.show{opacity:1;animation:huntBannerSlide 26s linear forwards;}
@keyframes huntBannerSlide{0%{transform:translateX(100%);}100%{transform:translateX(calc(-100% - 5px));}}

/* â”€â”€ PVP FIGHTER (reposicionado) â”€â”€â”€ */
.pvp-fighter{position:relative;}
.pvp-fighter img{width:70px;height:70px;border-radius:50%;border:3px solid #85a;object-fit:cover;background:#222;}

#eliminatedModal .modal-content{border-color:#c22;background:#1a0808;}
#eliminatedModal h2{color:#f66;text-shadow:0 0 8px #f00;}

/* â”€â”€ DEAD PENALTY OVERLAY â”€â”€â”€ */
#deadPenaltyOverlay{display:none;position:fixed;bottom:75px;left:50%;transform:translateX(-50%);z-index:1500;flex-direction:column;align-items:center;gap:4px;pointer-events:none;}
#deadPenaltyAvatarWrap{position:relative;}
#deadPenaltyAvatar{width:72px;height:72px;border-radius:50%;border:3px solid #c22;filter:grayscale(80%) brightness(0.45);object-fit:cover;display:block;}
#deadPenaltyTimer{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff6666;font-weight:bold;font-size:.82em;text-align:center;text-shadow:0 0 6px #000,1px 1px 2px #000;background:rgba(0,0,0,.62);border-radius:5px;padding:2px 5px;white-space:nowrap;letter-spacing:1px;}
#deadPenaltyLabel{color:#f88;font-size:.58em;font-weight:bold;text-shadow:1px 1px 2px #000;background:rgba(0,0,0,.65);border-radius:4px;padding:2px 8px;}
@keyframes deadPulse{0%,100%{opacity:1}50%{opacity:.55}}
#deadPenaltyOverlay.active{animation:deadPulse 1.6s ease-in-out infinite;}

#rewardsModal .modal-content{border-color:#c92;background:#1c1808;max-width:460px;}
#rewardsModal h2{color:#fd8;text-shadow:0 0 8px #fa0;}
.region-rewards-block{margin:10px 0;text-align:left;}
.region-rewards-title{color:#fc8;font-size:.8em;font-weight:bold;border-bottom:1px solid #432;padding-bottom:4px;margin-bottom:6px;}
.reward-item-row{display:flex;align-items:center;gap:12px;margin:6px 0;background:rgba(255,255,255,.04);border:1px solid #432;border-radius:6px;padding:7px 10px;}
.reward-item-row img{width:44px;height:44px;border-radius:6px;border:1px solid #653;background:#111;object-fit:cover;flex-shrink:0;}
.reward-item-info{display:flex;flex-direction:column;gap:2px;}
.reward-item-name{color:#eda;font-size:.75em;font-weight:bold;}
.reward-item-qty{color:#fd8;font-size:1em;font-weight:bold;}
.reward-xp-row{display:flex;align-items:center;gap:8px;margin:8px 0 4px;padding:8px 12px;background:rgba(100,200,100,.08);border:1px solid #2a4a2a;border-radius:6px;}
.reward-xp-row span{color:#afa;font-size:.85em;}
.reward-xp-row strong{color:#8f8;font-size:1.1em;}

#playerTopBar {
  display: flex;
  align-items: flex-start;
  background: linear-gradient(to bottom, #444, #222);
  padding: 5px 5px;
  width: 100%;
  box-sizing: border-box;
  color: #e0dccc;
  font-family: 'Cinzel', serif;
  border-bottom: 2px solid #555;
  flex-wrap: wrap;
  top: 0;
}
</style>
<body>

<div id="playerTopBar">
    <a href="index.html?refresh=true" class="top-bar-link" title="Voltar">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
    </a>
    <span id="pageTitle" style="font-weight: bold; color: #ffc3c3;">Floresta MÃ­stica</span>
    <img id="tutorialBtn" src="https://aden-rpg.pages.dev/assets/tutorialbtn.webp" alt="Tutorial" style="width:30px;height:30px;cursor:pointer;">
</div>

<div id="mapContainer"><div id="map"></div></div>

<div id="contentOverlay">
    <div id="huntingHud">
        <div id="huntTimer">03:00:00</div>
        <div id="huntStatus">âš”ï¸ Escolha uma Ã¡rea para caÃ§ar</div>
        <div id="shieldHudRow" style="display:none;">
            <img src="https://aden-rpg.pages.dev/assets/itens/escudo_de_caca.webp" alt="ğŸ›¡">
            <span id="shieldHudText"></span>
        </div>
        <div id="hudBtnRow">
            <button class="hud-btn" id="pauseHuntBtn">Pausar</button>
            <button class="hud-btn" id="activateShieldBtn">ğŸ›¡ Ativar Escudo (x0)</button>
        </div>
    </div>
</div>

</div>

<div id="loadingOverlay"><div class="loading-spinner"></div></div>

<!-- Banner de kills/mortes globais -->
<div id="huntKillBanner"></div>

<!-- Overlay de penalidade de derrota PvP (cronÃ´metro no avatar) -->
<div id="deadPenaltyOverlay">
    <div id="deadPenaltyAvatarWrap">
        <img id="deadPenaltyAvatar" src="" alt="ğŸ’€">
        <div id="deadPenaltyTimer">03:00</div>
    </div>
    <div id="deadPenaltyLabel">ğŸ’€ Penalidade de derrota</div>
</div>

<!-- Ãudio de fundo PvP (mesma da mina) -->
<audio id="pvpBgMusic" src="https://aden-rpg.pages.dev/assets/mina.mp3" loop preload="none"></audio>

<div id="alertModal" class="modal-container">
    <div class="modal-content">
        <p id="alertMessage" style="font-size:.92em;color:#cec;margin:10px 0 16px;"></p>
        <div class="modal-btn-row"><button id="alertOkBtn" class="modal-btn">OK</button></div>
    </div>
</div>

<div id="confirmModal" class="modal-container">
    <div class="modal-content">
        <h3 id="confirmTitle">Confirmar</h3>
        <p id="confirmMsg" style="color:#cdc;font-size:.88em;"></p>
        <div class="modal-btn-row">
            <button id="confirmNoBtn" class="modal-btn">NÃ£o</button>
            <button id="confirmYesBtn" class="modal-btn">Sim</button>
        </div>
    </div>
</div>

<div id="pvpModal" class="modal-container">
    <div class="modal-content">
        <h2>âš”ï¸ Batalha</h2>
        <div id="pvpCountdown" style="display:none;"></div>
        <div class="pvp-arena">
            <div class="pvp-fighter" id="pvpAttackerSide">
                <div class="pvp-fighter-name" id="pvpAttackerName">Atacante</div>
                <img id="pvpAttackerAvatar" src="" alt="">
                <div class="pvp-hp-bg"><div class="pvp-hp-fill" id="pvpAttackerHpFill" style="width:100%"></div></div>
                <div class="pvp-hp-txt" id="pvpAttackerHpText">0/0</div>
            </div>
            <div class="pvp-vs">VS</div>
            <div class="pvp-fighter" id="pvpDefenderSide">
                <div class="pvp-fighter-name" id="pvpDefenderName">Defensor</div>
                <img id="pvpDefenderAvatar" src="" alt="">
                <div class="pvp-hp-bg"><div class="pvp-hp-fill" id="pvpDefenderHpFill" style="width:100%"></div></div>
                <div class="pvp-hp-txt" id="pvpDefenderHpText">0/0</div>
            </div>
        </div>
    </div>
</div>

<div id="eliminatedModal" class="modal-container">
    <div class="modal-content">
        <h2>ğŸ’€ Eliminado!</h2>
        <p>VocÃª foi eliminado por <strong id="eliminatedByName">um inimigo</strong>.</p>
        <p style="font-size:.78em;color:#c88;">Sua caÃ§a foi pausada. Clique em uma Ã¡rea para retomar.</p>
        <div class="modal-btn-row"><button id="eliminatedCloseBtn" class="modal-btn">Entendido</button></div>
    </div>
</div>

<!-- Modal de recompensas â€” agrupa por regiÃ£o -->
<div id="rewardsModal" class="modal-container">
    <div class="modal-content">
        <h2>ğŸ‰ Dia de CaÃ§a Completo!</h2>
        <div id="rewardsContent"></div>
        <div class="modal-btn-row"><button id="rewardsCloseBtn" class="modal-btn">Coletar!</button></div>
    </div>
</div>

<div id="huntInfoModal" class="modal-container">
    <div class="modal-content">
        <span class="modal-close" id="huntInfoClose">&times;</span>
        <h2>Floresta MÃ­stica</h2>
        <div style="text-align:left;color:#cdc;font-size:.82em;line-height:1.7;">
            <p><strong style="color:#fcc;">Drops:</strong><br>
            <strong>UnicÃ³rnio</strong> â†’ Chifre de UnicÃ³rnio<br>
            <strong>FÃªnix</strong> â†’ LÃ¡grima de FÃªnix<br>
            <strong>SÃ¡tiro</strong> â†’ Galho Espiritual<br>
            <strong>Tigre Nix</strong> â†’ Pele Animal</p>
            <p><strong style="color:#fd8;">â± Tempo:</strong> O contador de <strong>3 horas</strong> Ã© compartilhado entre todas as regiÃµes do jogo. VocÃª pode dividir o tempo como quiser.</p>
            <p><strong style="color:#afa;">Recompensas:</strong>
            <ul>
            <li><strong>XP:</strong> 350.</li>
            <li><strong>Itens:</strong> DistribuÃ­dos proporcionalmente ao tempo gasto em cada regiÃ£o/spot ao final das 3h.</li></ul></p>
            <p><strong style="color:#acf;">ğŸ›¡ Escudo:</strong> Protege de PvP por 1 hora por uso (mÃ¡x. 3h).</p>
            <p style="color:#fd8;font-size:.9em;">âš ï¸ PvP Ã© livre nesta regiÃ£o!</p>
            
         <br>  <hr><br>
    <center><h2>HistÃ³ria</h2></center>
    <p>Situada na periferia ocidental da lendÃ¡ria <strong>Selva de Ã‰ter</strong>, fazendo fronteira com as terras Ã©lficas de Elendor, a <strong>Floresta MÃ­stica</strong> nÃ£o Ã© uma criaÃ§Ã£o natural, mas sim uma consequÃªncia geolÃ³gica da magia. Durante dias sombrios e ameaÃ§as ao lar dos elfos, o CÃ­rculo dos GuardiÃµes da Semente tomou uma medida desesperada: sobrecarregaram a "Teia Viva" â€” a rede neural mÃ¡gica que conecta as Ãrvores-MÃ£e.</p>

    <p>Para evitar que o nÃºcleo de Elendor colapsasse sob o peso de tanta energia defensiva, o excesso de mana foi desviado e purgado para uma regiÃ£o de mata virgem adjacente. O solo, bombardeado por torrentes de energia vital bruta e desenfreada, sofreu uma mutaÃ§Ã£o instantÃ¢nea. A flora nÃ£o apenas cresceu; ela evoluiu agressivamente, tornando-se um bioma senciente de cores vibrantes e perigos letais, onde a prÃ³pria realidade parece vibrar em uma frequÃªncia diferente do restante de Aden.</p>

   <center> <h2>O FenÃ´meno: A SaturaÃ§Ã£o PrismÃ¡tica</h2></center>
    <p>Diferente da harmonia cultivada em Elendor, a Floresta MÃ­stica Ã© regida pelo caos da superabundÃ¢ncia. O ar Ã© denso, carregado de esporos luminosos que distorcem a percepÃ§Ã£o de distÃ¢ncia e tempo. Ali, a vida nÃ£o segue o ciclo natural de nascimento e morte, mas sim de transmutaÃ§Ã£o constante. Ã‰ um lugar onde a natureza nÃ£o Ã© passiva; ela Ã© uma predadora voraz que busca consumir qualquer fonte externa de magia para continuar sua expansÃ£o.</p>

    <p>Esta saturaÃ§Ã£o de energia atraiu e alterou permanentemente a fauna local. As criaturas que habitam a Floresta MÃ­stica nÃ£o sÃ£o monstros das sombras, mas bestas de pura luz e fÃºria elemental, existindo em um estado perpÃ©tuo de superestimulaÃ§Ã£o mÃ¡gica.</p>

    <center><h2>Os Habitantes: GuardiÃµes da Luz CaÃ³tica</h2></center>
    <p>As entidades que vagam por entre as Ã¡rvores de casca prateada sÃ£o manifestaÃ§Ãµes fÃ­sicas desse poder excedente.</p>

    <p><strong>O UnicÃ³rnio Cintilante:</strong> Outrora um sÃ­mbolo de pureza, na Floresta MÃ­stica ele Ã© uma tempestade galopante. Seu chifre nÃ£o Ã© apenas osso, mas um para-raios de mana solidificado, capaz de canalizar a energia instÃ¡vel do ambiente para obliterar intrusos.</p>

    <p><strong>A FÃªnix do Ã‰ter:</strong> Diferente de suas primas lendÃ¡rias, esta ave nÃ£o renasce das cinzas por escolha, mas por uma combustÃ£o interna incontrolÃ¡vel causada pelo excesso de magia em seu sangue. Suas lÃ¡grimas, procuradas por alquimistas, sÃ£o a Ãºnica substÃ¢ncia capaz de resfriar seu nÃºcleo ardente.</p>

    <p><strong>Os SÃ¡tiros da Vinha FÃ©rrea:</strong> Corrompidos pela densidade da floresta, estes seres tornaram-se os jardineiros dementes do local. Eles nÃ£o protegem a natureza por amor, mas por uma simbiose parasÃ­tica, utilizando galhos espirituais infundidos com a prÃ³pria alma da floresta para esmagar forasteiros.</p>

    <p><strong>O Tigre Nix:</strong> O predador alfa, cuja pele absorveu as propriedades camaleÃ´nicas da vegetaÃ§Ã£o mutante, tornando-o um fantasma listrado que ataca com a forÃ§a de um deslizamento de terra.</p>

   <center> <h2>O Interesse EconÃ´mico</h2></center>
    <p>Para os habitantes de Zion e os ferreiros de Mitrar, a Floresta MÃ­stica Ã© uma mina de ouro a cÃ©u aberto, embora mortal. Os materiais colhidos ali â€” chifres carregados de estÃ¡tica, lÃ¡grimas cristalizadas de calor eterno e madeira que pulsa com vida prÃ³pria â€” sÃ£o os componentes essenciais para a criaÃ§Ã£o de artefatos que exigem uma condutividade mÃ¡gica superior.</p>

    <p>Aventureiros nÃ£o entram na Floresta para salvar o mundo ou combater o mal antigo; eles entram para colher o fruto do caos, enfrentando a beleza aterrorizante de uma natureza que recebeu poder demais e agora se recusa a ser domada.</p>
            
        </div>
    </div>
</div>

<script>
document.addEventListener("DOMContentLoaded",()=>{
    const t=document.createElement("div");t.style.cssText="position:absolute;visibility:hidden;font-size:1rem;line-height:1;";t.textContent="M";document.body.appendChild(t);
    const r=t.getBoundingClientRect().height;document.body.removeChild(t);
    const s=document.createElement("style");s.textContent=`html{font-size:${16*(16/r)}px!important;}body{font-size:1.3rem!important;}`;document.head.appendChild(s);
});
</script>

<script type="module">
import { supabase } from './supabaseClient.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURAÃ‡ÃƒO DA REGIÃƒO â€” altere aqui para cada nova pÃ¡gina
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const REGION_ID = 'floresta_mistica';
const REGION_NAME = 'Floresta MÃ­stica';

// CatÃ¡logo de TODAS as regiÃµes (para o modal de recompensas)
// Adicione aqui as outras regiÃµes conforme criar as pÃ¡ginas
const ALL_REGIONS = {
    floresta_mistica: { name:'Floresta MÃ­stica' },
    // montanhas: { name:'Montanhas' },
};

// CatÃ¡logo de TODOS os itens de drop de todas as regiÃµes (para exibir no modal)
const ALL_DROPS = {
    84: { name:'Chifre de UnicÃ³rnio', img:'https://aden-rpg.pages.dev/assets/itens/chifre_de_unicornio.webp' },
    71: { name:'LÃ¡grima de FÃªnix',    img:'https://aden-rpg.pages.dev/assets/itens/lagrima_de_fenix.webp'    },
    74: { name:'Galho Espiritual',    img:'https://aden-rpg.pages.dev/assets/itens/galho_espiritual.webp'    },
    67: { name:'Pele Animal',               img:'https://aden-rpg.pages.dev/assets/itens/pele_animal.webp'               },
    // adicione outros drops aqui
};

const SPOTS = [
    { id:'unicornio', name:'UnicÃ³rnio',  top:320, left:190,  width:450, height:450,
      itemId:84, mobImg:'https://aden-rpg.pages.dev/assets/unicornio.webp', labelColor:'#ffccee' },
    { id:'fenix',    name:'FÃªnix',       top:430, left:830, width:500, height:430,
      itemId:71, mobImg:'https://aden-rpg.pages.dev/assets/fenix.webp',     labelColor:'#ffddaa' },
    { id:'satiro',   name:'SÃ¡tiro',      top:880, left:100, width:600, height:550,
      itemId:74, mobImg:'https://aden-rpg.pages.dev/assets/satiro.webp',    labelColor:'#aaffaa' },
    { id:'tigrenix', name:'Tigre Nix',   top:1120, left:850, width:500, height:360,
      itemId:51, mobImg:'https://aden-rpg.pages.dev/assets/tigre_nix.webp', labelColor:'#bbbbff' },
];

const SHIELD_ITEM_ID = 85;
const SHIELD_IMG     = 'https://aden-rpg.pages.dev/assets/itens/escudo_de_caca.webp';
const DEFAULT_AVATAR = 'https://aden-rpg.pages.dev/assets/default_avatar.png';
const DAILY_LIMIT    = 10800; // 3h globais â€” mesmo valor do SQL
const SPOT_LOCK_MS   = 15 * 60 * 1000; // 15 minutos de lock por spot

// â”€â”€ ADAPTIVE POLLING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const POLL_BASE = {
    hunting_with_others : 60_000,
    hunting_alone       : 90_000,
    paused_with_others  : 120_000,
    paused_alone        : 300_000,
    pvp_only            : 60_000,
};
const POLL_STEP     = 30_000;
const POLL_MAX_3MIN = 180_000;
const POLL_MAX_5MIN = 300_000;

// â”€â”€ HUNT STATE BOOT CACHE (120s) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HUNT_CACHE_KEY  = () => `hunt_state_${userId}`;
const HUNT_CACHE_TTL  = 120_000;

// â”€â”€ STATS CACHE (mesma chave do mines.js e afk_page.js) â”€â”€â”€â”€â”€â”€â”€
const STATS_CACHE_KEY       = () => `player_combat_stats_${userId}`;
const STATS_CACHE_DURATION  = 72 * 60 * 60 * 1000; // 72h

// â”€â”€ GLOBAL IDB (mesmo banco do mines.js â€” owners_store) â”€â”€â”€â”€â”€â”€â”€
const _GDBNAME    = 'aden_global_db';
const _GDBVER     = 6;
const _OWN_STORE  = 'owners_store';
const _OWNERS_TTL = 24 * 60 * 60 * 1000; // 24h

let _gdb = null;
async function _openGlobalDb(){
    if(_gdb) return _gdb;
    return new Promise((res,rej)=>{
        const req=indexedDB.open(_GDBNAME,_GDBVER);
        req.onerror=()=>rej(req.error);
        req.onsuccess=e=>{_gdb=e.target.result;res(_gdb);};
        req.onupgradeneeded=e=>{
            const db=e.target.result;
            if(!db.objectStoreNames.contains(_OWN_STORE))
                db.createObjectStore(_OWN_STORE,{keyPath:'id'});
        };
    });
}
async function _idbGetAllOwners(){
    try{
        const db=await _openGlobalDb();
        return new Promise(res=>{
            const tx=db.transaction(_OWN_STORE,'readonly');
            const req=tx.objectStore(_OWN_STORE).getAll();
            req.onsuccess=()=>{
                const now=Date.now(),map={};
                (req.result||[]).forEach(o=>{
                    if(o.id&&o.timestamp&&(now-o.timestamp)<_OWNERS_TTL)map[o.id]=o;
                });
                res(map);
            };
            req.onerror=()=>res({});
        });
    }catch{return{};}
}
async function _idbSaveOwners(list){
    if(!list||!list.length)return;
    try{
        const db=await _openGlobalDb();
        // Faz merge: lÃª o registro existente antes de sobrescrever
        // para nunca destruir guild_id que a mina jÃ¡ gravou.
        const now=Date.now();
        for(const o of list){
            const id=o.id||o.i;
            if(!id)continue;
            await new Promise(res=>{
                const txR=db.transaction(_OWN_STORE,'readonly');
                const req=txR.objectStore(_OWN_STORE).get(id);
                req.onsuccess=()=>{
                    const existing=req.result||{};
                    const merged={
                        id,
                        name       : o.name||o.n||existing.name||'',
                        avatar_url : o.avatar_url||o.a||existing.avatar_url||'',
                        // Preserva guild_id existente se o novo nÃ£o trouxer
                        guild_id   : o.guild_id||o.g||existing.guild_id||null,
                        timestamp  : now,
                    };
                    const txW=db.transaction(_OWN_STORE,'readwrite');
                    txW.objectStore(_OWN_STORE).put(merged);
                    txW.oncomplete=()=>res();
                    txW.onerror=()=>res();
                };
                req.onerror=()=>res();
            });
        }
    }catch(e){console.warn('[floresta] idb save',e);}
}
const ACTIVITY_KEY   = 'aden_activity_state';
// Chave dedicada ao lock de 15 min do spot â€” independente do ACTIVITY_KEY para
// sobreviver a navegaÃ§Ãµes que sobrescrevem ACTIVITY_KEY (mercador, cidade, mina, etc.)
const SPOT_LOCK_KEY  = () => `hunt_spot_lock_${userId}`;

// â”€â”€ ACTIVITY STATE (cache local compartilhado com mines.js) â”€
function getActivity(){
    try{
        const a=JSON.parse(localStorage.getItem(ACTIVITY_KEY));
        if(!a)return null;
        // Expira apÃ³s 6 horas sem interaÃ§Ã£o (previne bloqueio por crash)
        if(a.started_at&&(Date.now()-a.started_at)>6*60*60*1000){localStorage.removeItem(ACTIVITY_KEY);return null;}
        return a;
    }catch{return null;}
}
function setActivityHunting(spotId, forceResetLock = false){
    const cur=getActivity()||{};
    const keepTimer = !forceResetLock && cur.type==='hunting' && cur.spot_id===spotId;
    // Fallback: chave dedicada, sobrevive a ACTIVITY_KEY ser sobrescrita por outra pÃ¡gina
    const savedLockTs = (!forceResetLock && !keepTimer) ? _getSpotLockTs(spotId) : null;
    const lockTs = keepTimer ? cur.spot_started_at : (savedLockTs ?? Date.now());
    // Persiste na chave dedicada apenas quando o lock Ã© novo (nÃ£o sobrescreve um vÃ¡lido)
    if(!keepTimer && !savedLockTs){
        try{localStorage.setItem(SPOT_LOCK_KEY(),JSON.stringify({spot_id:spotId,locked_at:lockTs}));}catch{}
    } else if(forceResetLock){
        // Reset explÃ­cito (vitÃ³ria em PvP) â†’ grava novo timestamp
        try{localStorage.setItem(SPOT_LOCK_KEY(),JSON.stringify({spot_id:spotId,locked_at:Date.now()}));}catch{}
    }
    localStorage.setItem(ACTIVITY_KEY,JSON.stringify({
        type:'hunting',region:REGION_NAME,spot_id:spotId,
        spot_started_at: lockTs,
        started_at:Date.now()
    }));
}
function clearActivity(){
    localStorage.removeItem(ACTIVITY_KEY);
    try{localStorage.removeItem(SPOT_LOCK_KEY());}catch{}
}
function _getSpotLockTs(spotId){
    try{
        const raw=localStorage.getItem(SPOT_LOCK_KEY());
        if(!raw)return null;
        const o=JSON.parse(raw);
        return(o.spot_id===spotId&&o.locked_at)?o.locked_at:null;
    }catch{return null;}
}
function canSwitchSpot(){
    const a=getActivity();
    // Fonte primÃ¡ria: ACTIVITY_KEY (mais atualizado quando o jogador estÃ¡ na floresta)
    if(a&&a.type==='hunting'&&a.spot_started_at)return(Date.now()-a.spot_started_at)>=SPOT_LOCK_MS;
    // Fallback: chave dedicada (sobrevive quando ACTIVITY_KEY foi sobrescrito por outra pÃ¡gina)
    try{
        const raw=localStorage.getItem(SPOT_LOCK_KEY());
        if(raw){const o=JSON.parse(raw);if(o.locked_at)return(Date.now()-o.locked_at)>=SPOT_LOCK_MS;}
    }catch{}
    return true;
}
function fmtLockTime(){
    const a=getActivity();
    let lockedAt=null;
    if(a&&a.type==='hunting'&&a.spot_started_at)lockedAt=a.spot_started_at;
    if(!lockedAt){
        try{
            const raw=localStorage.getItem(SPOT_LOCK_KEY());
            if(raw){const o=JSON.parse(raw);if(o.locked_at)lockedAt=o.locked_at;}
        }catch{}
    }
    if(!lockedAt)return'0:00';
    const ms=Math.max(0,SPOT_LOCK_MS-(Date.now()-lockedAt));
    const total=Math.ceil(ms/1000);
    const m=Math.floor(total/60),s=total%60;
    return`${m}:${String(s).padStart(2,'0')}`;
}

// â”€â”€ ESTADO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let userId=null, playerData=null, currentSession=null;
let isHunting=false, isPvpOnly=false, currentSpotId=null, localSecondsLeft=DAILY_LIMIT;
let pvpOnlyExitTimer=null, pvpOnlySecondsLeft=900, pvpOnlyTimerInterval=null;
let eliminationModalShown=false;
function _elimAckKey(huntDate){return `elim_ack_${userId}_${huntDate||'today'}`;}
function isEliminationAcknowledged(huntDate){try{return localStorage.getItem(_elimAckKey(huntDate))==='1';}catch{return eliminationModalShown;}}
function setEliminationAcknowledged(huntDate){try{localStorage.setItem(_elimAckKey(huntDate),'1');}catch{}eliminationModalShown=true;}
function clearEliminationAcknowledged(huntDate){try{localStorage.removeItem(_elimAckKey(huntDate));}catch{}eliminationModalShown=false;}
let shieldUntil=null, cachedShieldQty=0;
let huntTimerInterval=null, shieldTimerInterval=null;
let otherPlayers=[], wanderTimers=[];

// â”€â”€ GUILD NAME CACHE (localStorage, TTL 48h) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Resolve guild_id (UUID) â†’ guild name sem RPC repetida.
// Chave separada para nÃ£o misturar com owners_store (que sÃ³ tem UUID).
const _GUILD_CACHE_KEY = 'aden_guild_names_cache';
const _GUILD_CACHE_TTL = 48 * 60 * 60 * 1000; // 48h

function _guildCacheLoad(){
    try{
        const raw=localStorage.getItem(_GUILD_CACHE_KEY);
        if(!raw)return{};
        const obj=JSON.parse(raw);
        const now=Date.now();
        // Filtra entradas expiradas ao carregar
        const valid={};
        Object.entries(obj).forEach(([id,entry])=>{
            if(entry.ts&&(now-entry.ts)<_GUILD_CACHE_TTL)valid[id]=entry;
        });
        return valid;
    }catch{return{};}
}
function _guildCacheSave(map){
    try{localStorage.setItem(_GUILD_CACHE_KEY,JSON.stringify(map));}catch{}
}
function _guildCacheGet(guildId){
    return _guildNamesCache[guildId]?.name||null;
}

let _guildNamesCache = _guildCacheLoad(); // { [guildId]: {name, ts} }

// Resolve em batch os guild_ids que ainda nÃ£o tÃªm nome em cache.
// Chamado de forma lazy apÃ³s render â€” nÃ£o bloqueia UI.
async function _resolveGuildNames(guildIds){
    if(!guildIds||!guildIds.length)return;
    const missing=guildIds.filter(id=>id&&!_guildNamesCache[id]);
    if(!missing.length)return;
    try{
        const{data,error}=await supabase.from('guilds').select('id,name').in('id',missing);
        if(error||!data)return;
        const now=Date.now();
        data.forEach(g=>{_guildNamesCache[g.id]={name:g.name,ts:now};});
        _guildCacheSave(_guildNamesCache);
        // Re-renderiza apenas se houver jogadores visÃ­veis com essas guilds
        const affected=otherPlayers.filter(p=>_ownersMap[p.id]?.guild_id&&missing.includes(_ownersMap[p.id].guild_id));
        if(affected.length)renderOtherPlayers(otherPlayers);
    }catch(e){console.warn('[floresta] guild resolve',e);}
}

// Busca guild_id de jogadores que ainda nÃ£o tÃªm no _ownersMap
// (ex: nunca foram donos de mina). Atualiza IDB + cache em memÃ³ria.
async function _fetchMissingGuildIds(playerIds){
    if(!playerIds||!playerIds.length)return;
    // Filtra apenas quem nÃ£o tem guild_id no mapa
    // Busca para qualquer jogador sem guild_id â€” inclusive os que ainda nÃ£o estÃ£o no _ownersMap
    const missing=playerIds.filter(id=>id&&(!_ownersMap[id]||!_ownersMap[id].guild_id));
    if(!missing.length)return;
    try{
        const{data,error}=await supabase.from('players').select('id,guild_id').in('id',missing);
        if(error||!data)return;
        let needsRerender=false;
        const toSave=[];
        data.forEach(row=>{
            if(!row.guild_id)return; // sem guilda, nÃ£o hÃ¡ o que salvar
            if(!_ownersMap[row.id])_ownersMap[row.id]={id:row.id};
            _ownersMap[row.id].guild_id=row.guild_id;
            toSave.push({id:row.id,guild_id:row.guild_id});
            needsRerender=true;
        });
        // Persiste no IDB com merge (preserva name/avatar)
        if(toSave.length)_idbSaveOwners(toSave).catch(()=>{});
        // Dispara _resolveGuildNames para os UUIDs recÃ©m obtidos
        const newGuildIds=[...new Set(toSave.map(o=>o.guild_id))];
        if(newGuildIds.length)await _resolveGuildNames(newGuildIds);
        // Re-render jÃ¡ Ã© chamado dentro de _resolveGuildNames se houver nomes novos.
        // Mas se nenhum guild_id foi encontrado (todos sem guilda), needsRerender=false. Correto.
    }catch(e){console.warn('[floresta] fetch guild_ids',e);}
}
let _ownersMap = {}; // { [playerId]: {name, avatar_url, guild_id} }

// â”€â”€ ADAPTIVE POLLING STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _syncTimeout     = null;
let _currentPollMs   = 30_000;
let _lastPlayersHash = '';

// â”€â”€ INACTIVITY GUARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _lastActivityMs    = Date.now();
let _inactivityCheckId = null;
let _inactivityPaused  = false;

// â”€â”€ DEAD STATE (derrota em PvP â€” 3 minutos) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let deadUntil=null; // timestamp ms
let deadTimer=null;
let deadOverlayInterval=null;
function isPlayerDead(){return deadUntil&&Date.now()<deadUntil;}

function _startDeadOverlay(){
    const overlay=document.getElementById('deadPenaltyOverlay');
    if(!overlay)return;
    const avImg=document.getElementById('deadPenaltyAvatar');
    if(avImg&&playerData)avImg.src=playerData.avatar_url||DEFAULT_AVATAR;
    overlay.style.display='flex';
    overlay.classList.add('active');
    const timerEl=document.getElementById('deadPenaltyTimer');
    clearInterval(deadOverlayInterval);
    const tick=()=>{
        const remaining=Math.max(0,Math.ceil((deadUntil-Date.now())/1000));
        const m=Math.floor(remaining/60),s=remaining%60;
        if(timerEl)timerEl.textContent=`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        if(remaining<=0){
            clearInterval(deadOverlayInterval);deadOverlayInterval=null;
            overlay.style.display='none';overlay.classList.remove('active');
        }
    };
    tick();
    deadOverlayInterval=setInterval(tick,1000);
}

function setPlayerDead(){
    deadUntil=Date.now()+3*60*1000;
    // Morte zera o lock de spot â€” limpa chave dedicada antes de sobrescrever ACTIVITY_KEY
    try{localStorage.removeItem(SPOT_LOCK_KEY());}catch{}
    localStorage.setItem(ACTIVITY_KEY,JSON.stringify({
        type:'hunting',region:REGION_NAME,spot_id:currentSpotId||'__dead__',
        pvp_dead:true,dead_until:deadUntil,started_at:Date.now()
    }));
    clearTimeout(deadTimer);
    deadTimer=setTimeout(()=>{
        deadUntil=null;
        // NÃ£o interrompe se o jogador jÃ¡ re-entrou em modo pvp puro durante os 3 min
        if(!isPvpOnly){
            if(currentSpotId){isHunting=false;stopLocalTimer();removePlayerFromSpot();currentSpotId=null;}
            clearTimeout(pvpOnlyExitTimer);
            clearActivity(); // jÃ¡ limpa SPOT_LOCK_KEY via clearActivity
        }
        updateHuntingHUD();
    },3*60*1000);
    _startDeadOverlay();
}
function clearDeadState(){
    deadUntil=null;clearTimeout(deadTimer);deadTimer=null;
    clearInterval(deadOverlayInterval);deadOverlayInterval=null;
    const overlay=document.getElementById('deadPenaltyOverlay');
    if(overlay){overlay.style.display='none';overlay.classList.remove('active');}
}

// â”€â”€ KILL BANNER QUEUE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _killBannerQueue=[];
let _killBannerShowing=false;
function createKillBannerUI(){
    let el=document.getElementById('huntKillBanner');
    if(!el){el=document.createElement('div');el.id='huntKillBanner';document.body.appendChild(el);}
}
function pushKillNotif(html){
    _killBannerQueue.push(html);
    if(!_killBannerShowing)_processKillQueue();
}
function _processKillQueue(){
    if(_killBannerShowing||_killBannerQueue.length===0)return;
    _killBannerShowing=true;
    const el=document.getElementById('huntKillBanner');
    if(!el){_killBannerShowing=false;return;}
    el.innerHTML=_killBannerQueue.shift();
    el.classList.remove('show');
    void el.offsetWidth;
    el.classList.add('show');
    const done=()=>{
        el.classList.remove('show');
        el.removeEventListener('animationend',done);
        _killBannerShowing=false;
        setTimeout(_processKillQueue,400);
    };
    el.addEventListener('animationend',done,{once:true});
}

// â”€â”€ INDEXEDDB (mesmo do mercador.js) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const IDB_NAME='aden_inventory_db',IDB_STORE='inventory_store',IDB_VERSION=47;
function openIdb(){return new Promise((res,rej)=>{const req=indexedDB.open(IDB_NAME,IDB_VERSION);req.onerror=()=>rej(req.error);req.onsuccess=e=>res(e.target.result);req.onupgradeneeded=()=>{};});}
async function getItemQtyFromCache(id){try{const db=await openIdb();if(!db.objectStoreNames.contains(IDB_STORE))return 0;const tx=db.transaction(IDB_STORE,'readonly');const all=await new Promise((res,rej)=>{const r=tx.objectStore(IDB_STORE).getAll();r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});return all.filter(i=>(i.items?.item_id===id)||(i.item_id===id)).reduce((s,i)=>s+(i.quantity||0),0);}catch{return 0;}}
async function updateCacheQty(id,delta){try{const db=await openIdb();if(!db.objectStoreNames.contains(IDB_STORE))return;const tx=db.transaction(IDB_STORE,'readwrite'),store=tx.objectStore(IDB_STORE);const all=await new Promise((res,rej)=>{const r=store.getAll();r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});const m=all.filter(i=>i.items?.item_id===id);if(!m.length)return;let rem=Math.abs(delta);if(delta<0){for(const item of m){if(rem<=0)break;if(item.quantity>=rem){item.quantity-=rem;rem=0;if(item.quantity<=0)store.delete(item.id);else store.put(item);}else{rem-=item.quantity;store.delete(item.id);}}}else{const item=m[0];item.quantity=(item.quantity||0)+delta;store.put(item);}}catch(e){console.warn('[floresta] IDB fail',e);}}

// â”€â”€ ÃUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const audioCtx=new(window.AudioContext||window.webkitAudioContext)();
const audioBufs={};
const SRC={normal:'https://aden-rpg.pages.dev/assets/normal_hit.mp3',critical:'https://aden-rpg.pages.dev/assets/critical_hit.mp3',evade:'https://aden-rpg.pages.dev/assets/evade.mp3',ambient:'https://aden-rpg.pages.dev/assets/floresta.mp3'};
async function preload(n){try{const r=await fetch(SRC[n],{cache:'force-cache'});if(!r.ok)return;const ab=await r.arrayBuffer();audioBufs[n]=await new Promise((res,rej)=>audioCtx.decodeAudioData(ab,res,rej));}catch{}}
function playSound(n){try{if(audioCtx.state==='suspended')audioCtx.resume();}catch{}const buf=audioBufs[n];if(!buf)return;try{const gain=audioCtx.createGain();gain.gain.value=(n==='critical'?0.07:1);gain.connect(audioCtx.destination);const s=audioCtx.createBufferSource();s.buffer=buf;s.connect(gain);s.start(0);s.onended=()=>{try{s.disconnect();gain.disconnect();}catch{}};}catch{}}
const amb=new Audio(SRC.ambient);amb.volume=0.12;amb.loop=true;
document.addEventListener('click',()=>{try{if(audioCtx.state==='suspended')audioCtx.resume();}catch{}amb.play().catch(()=>{});},{once:true});
document.addEventListener('visibilitychange',()=>{if(document.visibilityState==='hidden'){if(!amb.paused){amb.pause();amb._was=true;}}else{if(amb._was){amb.play().catch(()=>{});amb._was=false;}}});

// â”€â”€ AUTH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function getUserId(){try{for(let i=0;i<localStorage.length;i++){const k=localStorage.key(i);if(k?.startsWith('sb-')&&k.endsWith('-auth-token')){const s=JSON.parse(localStorage.getItem(k));if(s?.user?.id)return s.user.id;}}}catch{}try{const c=localStorage.getItem('player_data_cache');if(c){const p=JSON.parse(c);if(p?.data?.id)return p.data.id;}}catch{}try{const{data}=await supabase.auth.getSession();return data?.session?.user?.id||null;}catch{return null;}}
async function getPlayerData(){
    // 1. Contexto global (index.html popula)
    try{if(window.currentPlayerData?.id)return window.currentPlayerData;}catch{}
    // 2. player_data_cache
    try{const c=localStorage.getItem('player_data_cache');if(c){const p=JSON.parse(c);if(p?.data)return p.data;}}catch{}
    // 3. Fallback: combat stats cache (mesma chave do mines.js/afk) â€” tem name + avatar_url
    try{
        if(userId){
            const raw=localStorage.getItem(STATS_CACHE_KEY());
            if(raw){const parsed=JSON.parse(raw);if(parsed?.data?.name)return parsed.data;}
        }
    }catch{}
    return null;
}

// â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fmtTime(s){s=Math.max(0,Math.floor(s));return`${String(Math.floor(s/3600)).padStart(2,'0')}:${String(Math.floor((s%3600)/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;}
function esc(s){if(!s&&s!==0)return'';return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');}
function showLoading(){document.getElementById('loadingOverlay').style.display='flex';}
function hideLoading(){document.getElementById('loadingOverlay').style.display='none';}
function showAlert(msg){return new Promise(r=>{const m=document.getElementById('alertModal'),el=document.getElementById('alertMessage'),btn=document.getElementById('alertOkBtn');el.innerHTML=msg;m.style.display='flex';const close=()=>{m.style.display='none';btn.onclick=null;r();};btn.onclick=close;m.addEventListener('click',e=>{if(e.target===m)close();},{once:true});});}
function showConfirm(title,msg){return new Promise(r=>{const m=document.getElementById('confirmModal');document.getElementById('confirmTitle').textContent=title;document.getElementById('confirmMsg').innerHTML=msg;m.style.display='flex';const yes=document.getElementById('confirmYesBtn'),no=document.getElementById('confirmNoBtn');const done=v=>{m.style.display='none';yes.onclick=null;no.onclick=null;r(v);};yes.onclick=()=>done(true);no.onclick=()=>done(false);m.addEventListener('click',e=>{if(e.target===m)done(false);},{once:true});});}

// Modal com cronÃ´metro regressivo em tempo real (atualiza a cada segundo)
function showLiveCountdownAlert(msgFn){
    return new Promise(r=>{
        const m=document.getElementById('alertModal'),el=document.getElementById('alertMessage'),btn=document.getElementById('alertOkBtn');
        const tick=()=>{el.innerHTML=msgFn();};
        tick();
        m.style.display='flex';
        const iv=setInterval(tick,1000);
        const close=()=>{clearInterval(iv);m.style.display='none';btn.onclick=null;r();};
        btn.onclick=close;
        m.addEventListener('click',e=>{if(e.target===m)close();},{once:true});
    });
}

// â”€â”€ ESCUDO (global â€” sem region_id) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function initShieldFromCache(){cachedShieldQty=await getItemQtyFromCache(SHIELD_ITEM_ID);updateShieldBtn();}
function updateShieldBtn(){const btn=document.getElementById('activateShieldBtn');if(!btn)return;btn.textContent=`ğŸ›¡ Ativar Escudo (x${cachedShieldQty})`;btn.disabled=cachedShieldQty<=0;}
function isShieldActive(){return shieldUntil&&shieldUntil>new Date();}
function startShieldTimer(){clearInterval(shieldTimerInterval);const row=document.getElementById('shieldHudRow'),txt=document.getElementById('shieldHudText');if(!row||!txt)return;const tick=()=>{const diff=Math.max(0,Math.floor((shieldUntil-new Date())/1000));if(diff<=0){clearInterval(shieldTimerInterval);row.style.display='none';updateMyShieldIcon(false);return;}row.style.display='flex';txt.textContent=`Protegido por ${fmtTime(diff)}`;};tick();shieldTimerInterval=setInterval(tick,1000);}
async function handleActivateShield(){
    if(cachedShieldQty<=0){await showAlert('VocÃª nÃ£o tem <strong>Escudo de CaÃ§a</strong> no inventÃ¡rio!');return;}
    const ok=await showConfirm('ğŸ›¡ Escudo de CaÃ§a',`Ativar Escudo de CaÃ§a?<br><small style="color:#aab;">Protege de PvP por 1h. MÃ¡x. 3h acumuladas. VocÃª tem <strong>${cachedShieldQty}</strong>.</small>`);
    if(!ok)return;
    cachedShieldQty--;updateShieldBtn();await updateCacheQty(SHIELD_ITEM_ID,-1);
    showLoading();
    try{
        // RPC activate_hunt_shield agora nÃ£o precisa de p_region_id
        const{data,error}=await supabase.rpc('activate_hunt_shield',{p_player_id:userId});
        if(error)throw error;
        if(!data?.success){cachedShieldQty++;updateShieldBtn();await updateCacheQty(SHIELD_ITEM_ID,1);await showAlert(data?.message||'Erro.');return;}
        shieldUntil=new Date(data.shield_until);startShieldTimer();updateMyShieldIcon(true);
        await showAlert('ğŸ›¡ <strong>Escudo ativado!</strong>');
    }catch(e){cachedShieldQty++;updateShieldBtn();await updateCacheQty(SHIELD_ITEM_ID,1);await showAlert('Erro: '+(e.message||''));}
    finally{hideLoading();}
}
function updateMyShieldIcon(active){const el=document.getElementById('myShieldIcon');if(el)el.style.display=active?'block':'none';}

// â”€â”€ DRAG DO MAPA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function enableMapInteraction(){const cont=document.getElementById('mapContainer'),map=document.getElementById('map');if(!map||!cont)return;let drag=false,sx,sy,cx=0,cy=0,vx=0,vy=0,lt=0,aId=null;const limits=()=>{const cr=cont.getBoundingClientRect(),m=map.style.transform.match(/scale\(([^)]+)\)/),sc=m?parseFloat(m[1]):1.1;return{minX:Math.min(0,cr.width-1500*sc),maxX:0,minY:Math.min(0,cr.height-1500*sc),maxY:0};};const setPos=(x,y)=>{const L=limits();cx=Math.max(L.minX,Math.min(x,L.maxX));cy=Math.max(L.minY,Math.min(y,L.maxY));const m=map.style.transform.match(/scale\(([^)]+)\)/);map.style.transform=`translate(${cx}px,${cy}px) ${m?`scale(${m[1]})`:'scale(1.1)'}`;};const inertia=()=>{cancelAnimationFrame(aId);if(drag)return;vx*=0.94;vy*=0.94;setPos(cx+vx,cy+vy);if(Math.abs(vx)>0.4||Math.abs(vy)>0.4)aId=requestAnimationFrame(inertia);};const startDrag=e=>{if(e.touches?.length>1)return;drag=true;map.style.cursor='grabbing';sx=e.clientX??e.touches[0].clientX;sy=e.clientY??e.touches[0].clientY;vx=vy=0;lt=performance.now();cancelAnimationFrame(aId);};const onDrag=e=>{if(!drag)return;e.preventDefault();const nx=e.clientX??e.touches[0].clientX,ny=e.clientY??e.touches[0].clientY,dt=performance.now()-lt;if(dt>0){vx=(nx-sx)/dt;vy=(ny-sy)/dt;}setPos(cx+(nx-sx),cy+(ny-sy));sx=nx;sy=ny;lt=performance.now();};const endDrag=()=>{drag=false;map.style.cursor='grab';if(Math.abs(vx)>0.2||Math.abs(vy)>0.2){vx*=10;vy*=10;inertia();}};map.addEventListener('mousedown',startDrag,{passive:true});window.addEventListener('mousemove',onDrag,{passive:false});window.addEventListener('mouseup',endDrag,{passive:true});map.addEventListener('touchstart',startDrag,{passive:true});window.addEventListener('touchmove',onDrag,{passive:false});window.addEventListener('touchend',endDrag,{passive:true});map.style.cursor='grab';}

// â”€â”€ WANDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startWander(el,w,h,delay){const move=()=>{el.style.transition='left 3s ease-in-out,top 3s ease-in-out';el.style.left=Math.max(0,Math.random()*(w-70))+'px';el.style.top=Math.max(0,Math.random()*(h-90))+'px';wanderTimers.push(setTimeout(pause,3100+Math.random()*800));};const pause=()=>{wanderTimers.push(setTimeout(move,5000+Math.random()*2000));};wanderTimers.push(setTimeout(move,delay));}

// â”€â”€ SPOTS + MOBS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSpots(){const map=document.getElementById('map');map.querySelectorAll('.hunt-spot').forEach(e=>e.remove());SPOTS.forEach(spot=>{const el=document.createElement('div');el.className='hunt-spot';el.id=`spot-${spot.id}`;Object.assign(el.style,{top:spot.top+'px',left:spot.left+'px',width:spot.width+'px',height:spot.height+'px'});const lbl=document.createElement('div');lbl.className='spot-label';lbl.textContent=spot.name;lbl.style.color=spot.labelColor||'#fff';el.appendChild(lbl);for(let i=0;i<5;i++){const col=i%3,row=Math.floor(i/3);const wrap=document.createElement('div');wrap.className='mob-wrapper';Object.assign(wrap.style,{left:Math.min(10+col*80+Math.random()*20,spot.width-70)+'px',top:Math.min(15+row*80+Math.random()*20,spot.height-90)+'px'});const nm=document.createElement('div');nm.className='mob-name';nm.textContent=spot.name;nm.style.color=spot.labelColor||'#fcc';const av=document.createElement('img');av.className='mob-avatar';av.src=spot.mobImg;av.onerror=()=>{av.src=DEFAULT_AVATAR;};wrap.appendChild(nm);wrap.appendChild(av);el.appendChild(wrap);startWander(wrap,spot.width,spot.height,i*1400+Math.random()*3000);}el.addEventListener('click',e=>{if(e.target.closest('.other-player-wrapper'))return;handleSpotClick(spot);});map.appendChild(el);});}

// â”€â”€ AVATAR DO JOGADOR NO SPOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderPlayerOnSpot(spotId){
    document.querySelectorAll('.player-avatar-wrapper').forEach(e=>e.remove());
    if(!spotId||!playerData)return;
    const spotEl=document.getElementById(`spot-${spotId}`);if(!spotEl)return;
    const spot=SPOTS.find(s=>s.id===spotId);
    const wrap=document.createElement('div');wrap.className='player-avatar-wrapper';
    Object.assign(wrap.style,{right:'10px',bottom:'10px',left:'auto',top:'auto'});
    const si=document.createElement('img');si.id='myShieldIcon';si.className='player-shield-icon';si.src=SHIELD_IMG;si.style.display=isShieldActive()?'block':'none';wrap.appendChild(si);
    const nm=document.createElement('div');nm.className='player-name-label';nm.textContent=playerData.name||'VocÃª';wrap.appendChild(nm);
    // Guild do prÃ³prio jogador (silver, 0.65em)
    const myGuildId=_ownersMap[userId]?.guild_id||null;
    const myGuildName=myGuildId?_guildCacheGet(myGuildId):null;
    if(myGuildName){
        const gb=document.createElement('div');
        gb.className='player-name-label';
        gb.style.cssText='font-size:0.65em;color:silver;margin-top:-3px;text-shadow:1px 1px 2px #000;white-space:nowrap;';
        gb.textContent=esc(myGuildName);
        wrap.appendChild(gb);
    }
    const av=document.createElement('img');av.className='player-spot-avatar';av.src=playerData.avatar_url||DEFAULT_AVATAR;av.onerror=()=>{av.src=DEFAULT_AVATAR;};wrap.appendChild(av);
    spotEl.appendChild(wrap);
    if(spot)startWander(wrap,spot.width,spot.height,800);
}
function removePlayerFromSpot(){stopCombatLoop();document.querySelectorAll('.player-avatar-wrapper').forEach(e=>e.remove());}

// â”€â”€ OUTROS JOGADORES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Estado "morto" (perdeu PvP, penalidade 3 min):
//   is_hunting === false  AND  current_spot SET  AND  pvp_only_entered_at NULL  AND  NOT is_eliminated
// Estado "PvP puro":  is_hunting === false AND pvp_only_entered_at SET
// Estado "pausado":   current_spot === null
function _isDeadPenalty(p){
    return !p.is_hunting && p.current_spot && !p.pvp_only_entered_at && !p.is_eliminated;
}
function renderOtherPlayers(players){
    stopAllOtherCombatLoops();
    _otherCombatBusy.clear();
    document.querySelectorAll('.other-player-wrapper').forEach(e=>e.remove());

    const guildIdsToResolve=[];
    const playerIdsWithoutGuild=[];

    players.forEach(p=>{
        if(!p.current_spot)return;
        const spotEl=document.getElementById(`spot-${p.current_spot}`);
        if(!spotEl)return;
        const spot=SPOTS.find(s=>s.id===p.current_spot);

        const cached      = _ownersMap[p.id];
        const displayName = p.name       || cached?.name       || '?';
        const displayAvatar= p.avatar_url|| cached?.avatar_url || DEFAULT_AVATAR;
        const guildId     = cached?.guild_id || null;
        const guildName   = guildId ? _guildCacheGet(guildId) : null;
        const isDead      = _isDeadPenalty(p);

        // Agenda resoluÃ§Ãµes lazy
        if(guildId && !guildName)          guildIdsToResolve.push(guildId);
        if(cached && !cached.guild_id)     playerIdsWithoutGuild.push(p.id);
        if(!cached)                        playerIdsWithoutGuild.push(p.id);

        const wrap=document.createElement('div');
        wrap.className='other-player-wrapper';
        wrap.dataset.playerId=p.id;
        Object.assign(wrap.style,{
            left:(10+Math.random()*Math.max(10,(spot?.width||120)-80))+'px',
            top :(10+Math.random()*Math.max(10,(spot?.height||120)-90))+'px',
        });

        // Escudo
        const shActive=p.shield_until&&new Date(p.shield_until)>new Date();
        if(shActive){const si=document.createElement('img');si.className='other-player-shield';si.src=SHIELD_IMG;wrap.appendChild(si);}

        // Nome â€” 0.75em  â† TAMANHO DO NOME: altere aqui
        const nm=document.createElement('div');
        nm.className='other-player-name';
        nm.style.fontSize='0.75em';
        nm.textContent=esc(displayName);
        wrap.appendChild(nm);

        // Nome da guilda â€” 0.65em, silver, sem colchetes  â† TAMANHO DA GUILDA: altere aqui
        if(guildName){
            const gb=document.createElement('div');
            gb.className='other-player-name';
            gb.style.cssText='font-size:0.65em;color:silver;margin-top:-3px;';
            gb.textContent=esc(guildName);
            wrap.appendChild(gb);
        }

        // Avatar
        const av=document.createElement('img');
        av.className='other-player-avatar';
        if(p.is_eliminated||isDead) av.classList.add('eliminated');
        av.src=displayAvatar;
        av.onerror=()=>{av.src=DEFAULT_AVATAR;};
        wrap.appendChild(av);

        if(p.is_eliminated){
            // Eliminado permanentemente hoje
            const lbl=document.createElement('div');lbl.className='other-eliminated-label';lbl.textContent='Eliminado';wrap.appendChild(lbl);
        } else if(isDead){
            // Penalidade de derrota: mostra caveira, sem clique de ataque
            const lbl=document.createElement('div');lbl.className='other-eliminated-label';
            lbl.textContent='ğŸ’€ Derrota';lbl.style.color='#f88';wrap.appendChild(lbl);
        } else {
            wrap.addEventListener('click',e=>{e.stopPropagation();handleAttackPlayer(p);});
            if(spot)startWander(wrap,spot.width,spot.height,Math.random()*4000);
        }

        spotEl.appendChild(wrap);
    });

    if(players.some(p=>!p.is_eliminated&&!_isDeadPenalty(p)&&p.current_spot)){_ensureOtherCombatInterval();}

    // ResoluÃ§Ãµes lazy (nÃ£o bloqueiam o render)
    if(guildIdsToResolve.length)_resolveGuildNames([...new Set(guildIdsToResolve)]).catch(()=>{});
    if(playerIdsWithoutGuild.length)_fetchMissingGuildIds([...new Set(playerIdsWithoutGuild)]).catch(()=>{});
}

// â”€â”€ TIMER GLOBAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateTimerDisplay(){const el=document.getElementById('huntTimer');if(el)el.textContent=isPvpOnly?fmtTime(pvpOnlySecondsLeft):fmtTime(localSecondsLeft);}
function startLocalTimer(){clearInterval(huntTimerInterval);huntTimerInterval=setInterval(()=>{if(!isHunting)return;if(localSecondsLeft<=0){localSecondsLeft=0;clearInterval(huntTimerInterval);updateTimerDisplay();onHuntComplete();return;}localSecondsLeft--;updateTimerDisplay();},1000);startCombatLoop();}
function stopLocalTimer(){clearInterval(huntTimerInterval);huntTimerInterval=null;stopCombatLoop();}

// â”€â”€ TIMER PvP PURO (15 min) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startPvpOnlyTimer(resetToFull=true){
    clearInterval(pvpOnlyTimerInterval);
    if(resetToFull)pvpOnlySecondsLeft=900;
    updateTimerDisplay();
    pvpOnlyTimerInterval=setInterval(()=>{
        if(!isPvpOnly){clearInterval(pvpOnlyTimerInterval);return;}
        if(pvpOnlySecondsLeft<=0){clearInterval(pvpOnlyTimerInterval);exitPvpOnlyMode();return;}
        pvpOnlySecondsLeft--;updateTimerDisplay();
    },1000);
}
function stopPvpOnlyTimer(){clearInterval(pvpOnlyTimerInterval);pvpOnlyTimerInterval=null;}
function resetPvpOnlyTimer(){
    // Chamado apÃ³s vitÃ³ria em PvP â€” renova os 15 min
    pvpOnlySecondsLeft=900; // garante que o valor estÃ¡ no topo antes dos timeouts
    clearTimeout(pvpOnlyExitTimer);
    pvpOnlyExitTimer=setTimeout(exitPvpOnlyMode,pvpOnlySecondsLeft*1000);
    startPvpOnlyTimer(); // resetToFull=true implicitamente (jÃ¡ setamos acima)
    // Atualiza pvp_only_entered_at no servidor (fire and forget)
    supabase.rpc('start_pvp_only',{p_player_id:userId,p_region_id:REGION_ID,p_spot:currentSpotId}).catch(()=>{});
}

function updateHuntingHUD(){
    const hud=document.getElementById('huntingHud'),status=document.getElementById('huntStatus'),pauseBtn=document.getElementById('pauseHuntBtn');
    updateSpotStyles();
    if(currentSession?.rewards_claimed){hud.style.display='flex';status.textContent='âœ… Recompensas coletadas hoje!';pauseBtn.style.display='none';return;}

    // Modo PvP puro (tempo esgotado, entrou sÃ³ para pvp)
    if(isPvpOnly&&currentSpotId){
        hud.style.display='flex';pauseBtn.style.display='block';
        updateTimerDisplay();
        const spotName=SPOTS.find(s=>s.id===currentSpotId)?.name||currentSpotId;
        status.textContent=`âš”ï¸ Modo PvP: ${spotName}`;
        pauseBtn.textContent='Sair';pauseBtn.disabled=false;
        return;
    }

    if(localSecondsLeft<=0&&!isHunting){hud.style.display='none';return;}
    hud.style.display='flex';pauseBtn.style.display='block';updateTimerDisplay();
    if(isHunting&&currentSpotId){status.textContent=`âš”ï¸ CaÃ§ando: ${SPOTS.find(s=>s.id===currentSpotId)?.name||currentSpotId}`;pauseBtn.textContent='Pausar';pauseBtn.disabled=false;}
    else{status.textContent='â¸ï¸ Pausado â€” clique num spot para continuar';pauseBtn.textContent='Pausado';pauseBtn.disabled=true;}
}
function updateSpotStyles(){
    SPOTS.forEach(s=>{
        const el=document.getElementById(`spot-${s.id}`);
        if(!el)return;
        if((isHunting||isPvpOnly)&&currentSpotId===s.id)el.classList.add('active-spot');
        else el.classList.remove('active-spot');
    });
}

// â”€â”€ CONCLUSÃƒO DO DIA (timer global zera) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function onHuntComplete(){
    isHunting=false;stopLocalTimer();updateHuntingHUD();showLoading();
    try{
        // finish_daily_hunt distribui recompensas de TODAS as regiÃµes visitadas
        const{data,error}=await supabase.rpc('finish_daily_hunt',{p_player_id:userId});
        if(error)throw error;
        if(data?.success)showRewardsModal(data);
        else await showAlert(data?.message||'Erro ao finalizar.');
    }catch(e){await showAlert('Erro ao finalizar. Tente novamente.');}
    finally{hideLoading();}
}

// â”€â”€ CLICK NO SPOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handleSpotClick(spot){

    // Bloqueado por morte em PvP
    if(isPlayerDead()){
        await showLiveCountdownAlert(()=>{
            const secsLeft=Math.max(0,Math.ceil((deadUntil-Date.now())/1000));
            const m=Math.floor(secsLeft/60),s=secsLeft%60;
            return `ğŸ’€ VocÃª estÃ¡ no chÃ£o apÃ³s a derrota.<br>Aguarde <strong>${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}</strong> para se recuperar.`;
        });
        return;
    }

    // Tempo de caÃ§a esgotado â€” oferecer modo PvP puro
    if(localSecondsLeft<=0&&!isPvpOnly){
        const ok=await showConfirm('âš”ï¸ Modo PvP Puro',
            `Seu tempo de caÃ§ada terminou, mas vocÃª pode entrar em <strong>${esc(spot.name)}</strong> exclusivamente para PvP.<br><small style="color:#fd8;">â± VocÃª precisarÃ¡ ficar no spot por <strong>15 minutos</strong>. Vencer um ataque renova o tempo.</small>`);
        if(!ok)return;
        // Entra no modo PvP puro (sem RPC start_hunt â€” tempo jÃ¡ acabou)
        showLoading();
        try{
            const{data:pvpData,error:pvpErr}=await supabase.rpc('start_pvp_only',{p_player_id:userId,p_region_id:REGION_ID,p_spot:spot.id});
            if(pvpErr)throw pvpErr;
            if(!pvpData?.success){await showAlert(pvpData?.message||'Erro ao entrar no modo PvP.');return;}
            clearEliminationAcknowledged(currentSession?.hunt_date); // libera ack para prÃ³xima eliminaÃ§Ã£o
            clearTimeout(pvpOnlyExitTimer);
            isPvpOnly=true;currentSpotId=spot.id;isHunting=false;
            clearTimeout(deadTimer);deadTimer=null;
            // Invalida boot cache para reloads dentro do TTL nÃ£o carregarem estado desatualizado
            try{localStorage.removeItem(HUNT_CACHE_KEY());}catch{}
            setActivityHunting(spot.id);
            renderPlayerOnSpot(spot.id);
            startPvpOnlyTimer();
            pvpOnlyExitTimer=setTimeout(exitPvpOnlyMode,SPOT_LOCK_MS);
            updateHuntingHUD();
            _resetPollInterval();scheduleNextSync();
        }catch(e){await showAlert('Erro: '+(e.message||''));}
        finally{hideLoading();}
        return;
    }

    // JÃ¡ no mesmo spot (caÃ§a normal ou pvp puro) â€” nada a fazer
    if(currentSpotId===spot.id)return;

    // Tentativa de trocar de spot enquanto em modo pvp puro
    if(isPvpOnly){
        if(!canSwitchSpot()){
            await showLiveCountdownAlert(()=>`â³ VocÃª precisa aguardar mais <strong>${fmtLockTime()}</strong> antes de trocar de spot.`);return;
        }
        clearTimeout(pvpOnlyExitTimer);
        currentSpotId=spot.id;
        setActivityHunting(spot.id);
        renderPlayerOnSpot(spot.id);updateHuntingHUD();
        startPvpOnlyTimer();
        pvpOnlyExitTimer=setTimeout(exitPvpOnlyMode,SPOT_LOCK_MS);
        supabase.rpc('start_pvp_only',{p_player_id:userId,p_region_id:REGION_ID,p_spot:spot.id}).catch(()=>{});
        updateHuntingHUD();
        return;
    }

    // Verifica se estÃ¡ minerando em outra pÃ¡gina
    const activity=getActivity();
    if(activity?.type==='mining'){
        await showAlert('â›ï¸ <strong>VocÃª nÃ£o Ã© onipresente...</strong><br>No momento vocÃª estÃ¡ minerando.<br>Aguarde o tÃ©rmino da mineraÃ§Ã£o.');
        return;
    }

    // Regra: lock de 15 minutos antes de trocar de spot
    if(isHunting&&currentSpotId&&currentSpotId!==spot.id){
        if(!canSwitchSpot()){
            await showLiveCountdownAlert(()=>`â³ VocÃª precisa aguardar mais <strong>${fmtLockTime()}</strong> antes de trocar de spot.`);
            return;
        }
    }

    const ok=await showConfirm('Ãrea de CaÃ§a',`CaÃ§ar na Ã¡rea de <strong>${esc(spot.name)}</strong>?`);
    if(!ok)return;
    showLoading();
    try{
        const{data,error}=await supabase.rpc('start_hunt',{p_player_id:userId,p_region_id:REGION_ID,p_spot:spot.id});
        if(error)throw error;
        if(!data?.success){await showAlert(data?.message||'Erro ao iniciar.');return;}
        localSecondsLeft=Math.max(0,DAILY_LIMIT-(data.total_seconds||0));
        clearEliminationAcknowledged(data.hunt_date); // ao entrar no spot, libera ack para prÃ³xima eliminaÃ§Ã£o
        currentSpotId=spot.id;isHunting=true;isPvpOnly=false;
        if(!currentSession)currentSession={};
        currentSession.current_region=REGION_ID;currentSession.current_spot=spot.id;
        // Invalida boot cache â€” garante que reloads dentro de 180s nÃ£o restaurem estado prÃ©-caÃ§ada
        try{localStorage.removeItem(HUNT_CACHE_KEY());}catch{}
        setActivityHunting(spot.id);
        renderPlayerOnSpot(spot.id);updateHuntingHUD();startLocalTimer();amb.play().catch(()=>{});
        _resetPollInterval();scheduleNextSync();
    }catch(e){await showAlert('Erro: '+(e.message||''));}
    finally{hideLoading();}
}

function exitPvpOnlyMode(){
    isPvpOnly=false;currentSpotId=null;
    clearTimeout(pvpOnlyExitTimer);
    stopPvpOnlyTimer();
    clearActivity();removePlayerFromSpot();updateHuntingHUD();
}

// â”€â”€ PAUSAR / SAIR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handlePauseHunt(){
    // Modo PvP puro â€” "Sair" Ã© apenas local
    if(isPvpOnly){
        if(!canSwitchSpot()){
            await showLiveCountdownAlert(()=>`â³ VocÃª precisa aguardar mais <strong>${fmtLockTime()}</strong> antes de sair.`);return;
        }
        exitPvpOnlyMode();
        return;
    }
    if(!isHunting)return;
    // Penalidade de morte ativa?
    if(isPlayerDead()){
        await showLiveCountdownAlert(()=>{
            const secsLeft=Math.max(0,Math.ceil((deadUntil-Date.now())/1000));
            const m=Math.floor(secsLeft/60),s=secsLeft%60;
            return `ğŸ’€ VocÃª estÃ¡ no chÃ£o apÃ³s a derrota.<br>Aguarde <strong>${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}</strong> para se recuperar.`;
        });
        return;
    }
    if(!canSwitchSpot()){
        await showLiveCountdownAlert(()=>`â³ VocÃª precisa aguardar mais <strong>${fmtLockTime()}</strong> antes de pausar.`);
        return;
    }
    showLoading();
    try{
        const{data,error}=await supabase.rpc('pause_hunt',{p_player_id:userId});
        if(error)throw error;
        isHunting=false;stopLocalTimer();
        if(data?.total_seconds!==undefined){localSecondsLeft=Math.max(0,DAILY_LIMIT-data.total_seconds);updateTimerDisplay();}
        currentSpotId=null; // permite re-entrar no mesmo spot apÃ³s pausar
        // Invalida boot cache para reloads dentro do TTL nÃ£o restaurarem sessÃ£o ativa erroneamente
        try{localStorage.removeItem(HUNT_CACHE_KEY());}catch{}
        clearActivity();
        removePlayerFromSpot();updateHuntingHUD();
        _resetPollInterval();scheduleNextSync();
    }catch(e){await showAlert('Erro ao pausar.');}
    finally{hideLoading();}
}

// â”€â”€ PVP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handleAttackPlayer(target){
    // Verifica se estÃ¡ morto (derrota recente)
    if(isPlayerDead()){
        await showLiveCountdownAlert(()=>{
            const secsLeft=Math.max(0,Math.ceil((deadUntil-Date.now())/1000));
            const m=Math.floor(secsLeft/60),s=secsLeft%60;
            return `ğŸ’€ VocÃª estÃ¡ no chÃ£o.<br>Aguarde <strong>${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}</strong> para se recuperar.`;
        });
        return;
    }
    // Bloqueia ataque em jogador que estÃ¡ em penalidade de derrota
    if(_isDeadPenalty(target)){
        await showAlert(`ğŸ’€ <strong>${esc(target.name)}</strong> estÃ¡ derrotado. Aguarde ele se recuperar.`);return;
    }
    // Verifica mineraÃ§Ã£o em outra aba
    const activity=getActivity();
    if(activity?.type==='mining'){
        await showAlert('â›ï¸ <strong>VocÃª nÃ£o Ã© onipresente...</strong><br>No momento vocÃª estÃ¡ minerando.<br>Aguarde o tÃ©rmino da mineraÃ§Ã£o.');return;
    }
    // SÃ³ pode atacar se estiver caÃ§ando OU em modo PvP puro no mesmo spot
    if(!isHunting&&!isPvpOnly){
        await showAlert('âš”ï¸ VocÃª precisa estar em um spot para atacar outros jogadores.');return;
    }
    if(currentSpotId!==target.current_spot){
        await showAlert('âš”ï¸ VocÃª sÃ³ pode atacar jogadores no mesmo spot que vocÃª.');return;
    }
    // JÃ¡ eliminado localmente?
    if(target.is_eliminated){
        await showAlert(`ğŸ’€ <strong>${esc(target.name)}</strong> jÃ¡ foi eliminado.`);return;
    }
    // â”€â”€ Sync prÃ©-ataque (fix: evita falso "nÃ£o estÃ¡ caÃ§ando" por last_seen stale) â”€â”€
    // Atualiza nossa lista local antes de confirmar o ataque.
    await syncOtherPlayers().catch(()=>{});
    // Reavalia alvo apÃ³s sync â€” pode ter saÃ­do do spot entre o clique e agora
    const freshTarget = otherPlayers.find(p=>p.id===target.id);
    if(!freshTarget){
        await showAlert(`âš”ï¸ <strong>${esc(target.name)}</strong> nÃ£o estÃ¡ mais neste spot.`);return;
    }
    if(_isDeadPenalty(freshTarget)){
        await showAlert(`ğŸ’€ <strong>${esc(target.name)}</strong> estÃ¡ derrotado. Aguarde ele se recuperar.`);return;
    }
    // Usa objeto atualizado daqui em diante
    target = freshTarget;
    // Escudo do atacante: avisar que perderÃ¡ proteÃ§Ã£o
    if(isShieldActive()){
        const okShield=await showConfirm('âš ï¸ Escudo Ativo',
            `Tem certeza que deseja atacar <strong>${esc(target.name)}</strong>?<br><small style="color:#f88;">Essa aÃ§Ã£o farÃ¡ vocÃª perder o Escudo de CaÃ§a.</small>`);
        if(!okShield)return;
        // Remove escudo localmente
        shieldUntil=null;
        clearInterval(shieldTimerInterval);
        document.getElementById('shieldHudRow').style.display='none';
        updateMyShieldIcon(false);
    } else {
        const ok=await showConfirm('PvP',`Deseja atacar <strong>${esc(target.name)}</strong>?`);if(!ok)return;
    }
    showLoading();
    let pvpData=null;
    try{
        const{data,error}=await supabase.rpc('attack_hunting_player',{p_attacker_id:userId,p_defender_id:target.id,p_region_id:REGION_ID});
        if(error)throw error;
        if(!data?.success){
            // Banco confirmou que defensor jÃ¡ estava morto â€” atualiza UI local
            if(data?.already_eliminated){
                otherPlayers=otherPlayers.map(p=>p.id===target.id
                    ?{...p,is_eliminated:true,eliminated_by_name:data.eliminated_by_name||'alguÃ©m'}
                    :p);
                renderOtherPlayers(otherPlayers);
                await showAlert(`ğŸ’€ <strong>${esc(target.name)}</strong> jÃ¡ havia sido eliminado por <strong>${esc(data.eliminated_by_name||'alguÃ©m')}</strong>.`);
                return;
            }
            await showAlert(data?.message||'Erro no PvP.');return;
        }
        pvpData=data;
    }catch(e){await showAlert('Erro no PvP: '+(e.message||''));return;}
    finally{hideLoading();}

    // Anima com loading jÃ¡ escondido
    await runPvpAnimation(pvpData);

    const myName=playerData?.name||'VocÃª';
    const regionNameDisplay=REGION_NAME;
    if(pvpData.combat?.winner_id===userId){
        // VITÃ“RIA â€” banner otimista imediato (nÃ£o espera o sync global)
        const kTxt=pvpData.attacker_daily_kills>0?`, eliminando um total de <span style="color:#ff8">${pvpData.attacker_daily_kills}</span> hoje!`:'!';
        pushKillNotif(
            `<span style="color:#ff8">${esc(myName)}</span> acabou de eliminar `+
            `<span style="color:#f88">${esc(pvpData.defender_name)}</span> em `+
            `<span style="color:#8ff">${esc(regionNameDisplay)}</span>${kTxt}`
        );
        // PrÃ©-marca o evento como visto para o syncGlobal nÃ£o duplicar
        if(pvpData.pvp_event_id){
            const seenKey=`hunt_pvp_seen_${userId}`;
            try{const seen=new Set(JSON.parse(localStorage.getItem(seenKey)||'[]'));seen.add(pvpData.pvp_event_id);localStorage.setItem(seenKey,JSON.stringify([...seen].slice(-200)));}catch{}
        }
        otherPlayers=otherPlayers.map(p=>p.id===target.id?{...p,is_eliminated:true,eliminated_by_name:myName}:p);
        renderOtherPlayers(otherPlayers);
        // Reseta lock de 15 min
        if(currentSpotId)setActivityHunting(currentSpotId, true);
        if(isPvpOnly)resetPvpOnlyTimer();
    } else {
        // DERROTA â€” fica morto 3 min
        isHunting=false;isPvpOnly=false;stopLocalTimer();stopPvpOnlyTimer();removePlayerFromSpot();
        clearTimeout(pvpOnlyExitTimer);
        if(currentSpotId)setActivityHunting(currentSpotId, true);
        currentSpotId=null;
        clearActivity();updateHuntingHUD();
        setPlayerDead();
    }
    // Sincroniza evento global imediatamente para todos verem
    syncGlobalPvpEvents();
    syncOtherPlayers();
}

async function runPvpAnimation(data){
    const modal=document.getElementById('pvpModal'),combat=data.combat||{},log=combat.battle_log||[];
    const pvpBgMusic=document.getElementById('pvpBgMusic');
    document.getElementById('pvpAttackerName').textContent=data.attacker_name||'Atacante';
    document.getElementById('pvpDefenderName').textContent=data.defender_name||'Defensor';
    const atkAv=document.getElementById('pvpAttackerAvatar'),defAv=document.getElementById('pvpDefenderAvatar');
    atkAv.src=data.attacker_avatar||playerData?.avatar_url||DEFAULT_AVATAR;defAv.src=data.defender_avatar||DEFAULT_AVATAR;
    atkAv.onerror=()=>{atkAv.src=DEFAULT_AVATAR;};defAv.onerror=()=>{defAv.src=DEFAULT_AVATAR;};
    const atkFill=document.getElementById('pvpAttackerHpFill'),defFill=document.getElementById('pvpDefenderHpFill');
    const atkTxt=document.getElementById('pvpAttackerHpText'),defTxt=document.getElementById('pvpDefenderHpText');
    const atkSide=document.getElementById('pvpAttackerSide'),defSide=document.getElementById('pvpDefenderSide');
    const cntdn=document.getElementById('pvpCountdown');
    const atkId=combat.attacker_id,defId=combat.defender_id;
    const dmgToDef=log.filter(t=>t.attacker_id===atkId).reduce((s,t)=>s+(t.damage||0),0);
    const dmgToAtk=log.filter(t=>t.attacker_id===defId).reduce((s,t)=>s+(t.damage||0),0);
    const defMaxHp=Math.max(1,(combat.defender_health_left||0)+dmgToDef);
    const atkMaxHp=Math.max(1,(combat.attacker_health_left||0)+dmgToAtk);
    let curAtk=atkMaxHp,curDef=defMaxHp;
    function updBars(){
        atkFill.style.width=Math.max(0,curAtk/atkMaxHp*100)+'%';
        defFill.style.width=Math.max(0,curDef/defMaxHp*100)+'%';
        atkTxt.textContent=Math.max(0,curAtk)+'/'+atkMaxHp;
        defTxt.textContent=Math.max(0,curDef)+'/'+defMaxHp;
    }
    updBars();modal.style.display='flex';cntdn.style.display='block';
    // MÃºsica de combate (estilo mina)
    try{if(audioCtx.state==='suspended')audioCtx.resume();}catch{}
    if(pvpBgMusic){pvpBgMusic.currentTime=0;pvpBgMusic.volume=0.12;pvpBgMusic.play().catch(()=>{});}
    for(let i=3;i>0;i--){cntdn.textContent='A batalha comeÃ§a em '+i+'...';await new Promise(r=>setTimeout(r,1000));}
    cntdn.style.display='none';
    for(const turn of log){
        const isAtk=turn.attacker_id===atkId;
        const tgtSide=isAtk?defSide:atkSide,tgtAv=isAtk?defAv:atkAv;
        if(isAtk)curDef=Math.max(0,curDef-(turn.damage||0));
        else curAtk=Math.max(0,curAtk-(turn.damage||0));
        updBars();
        _showDmgOnSide(turn.damage,turn.critical,turn.evaded,tgtSide);
        if(turn.evaded)playSound('evade');
        else if(turn.critical)playSound('critical');
        else playSound('normal');
        tgtAv.classList.remove('shake-animation');void tgtAv.offsetWidth;tgtAv.classList.add('shake-animation');
        setTimeout(()=>tgtAv.classList.remove('shake-animation'),400);
        await new Promise(r=>setTimeout(r,1000));
    }
    await new Promise(r=>setTimeout(r,600));
    if(pvpBgMusic){pvpBgMusic.pause();pvpBgMusic.currentTime=0;}
    modal.style.display='none';
    if(combat.winner_id===userId)await showAlert('âš”ï¸ <strong>VITÃ“RIA!</strong><br>'+esc(data.defender_name)+' foi eliminado!');
    else await showAlert('âš”ï¸ <strong>DERROTA.</strong><br>'+esc(data.defender_name)+' sobreviveu!');
}
function _showDmgOnSide(dmg,crit,evaded,sideEl){
    const el=document.createElement('div');
    if(evaded){el.textContent='Desviou';el.className='evade-text';}
    else{el.textContent=Number(dmg).toLocaleString();el.className=crit?'crit-damage-number':'damage-number';}
    sideEl.style.position='relative';
    sideEl.appendChild(el);
    el.addEventListener('animationend',()=>el.remove(),{once:true});
}

// â”€â”€ MODAL DE RECOMPENSAS â€” agrupa por regiÃ£o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showRewardsModal(data){
    const modal=document.getElementById('rewardsModal'),content=document.getElementById('rewardsContent');
    const rewards=data.rewards||[]; // [{region_id, item_id, quantity}]
    const xpGained=data.xp_gained||0;

    // Agrupa por regiÃ£o
    const byRegion={};
    rewards.forEach(r=>{if(!byRegion[r.region_id])byRegion[r.region_id]=[];byRegion[r.region_id].push(r);});

    let html=`<div class="reward-xp-row"><span>âœ¨ XP Total Ganho:</span><strong>+${xpGained}</strong></div>`;

    if(Object.keys(byRegion).length===0){
        html+='<p style="color:#aab;font-size:.82em;">Nenhuma recompensa (tempo insuficiente em qualquer regiÃ£o).</p>';
    } else {
        Object.entries(byRegion).forEach(([rid,items])=>{
            const regionName=ALL_REGIONS[rid]?.name||rid;
            html+=`<div class="region-rewards-block"><div class="region-rewards-title">ğŸ“ ${esc(regionName)}</div>`;
            items.forEach(g=>{
                const drop=ALL_DROPS[g.item_id];
                const img=drop?.img||DEFAULT_AVATAR;
                const name=drop?.name||`Item #${g.item_id}`;
                html+=`<div class="reward-item-row"><img src="${img}" alt="${esc(name)}" onerror="this.src='${DEFAULT_AVATAR}'"><div class="reward-item-info"><div class="reward-item-name">${esc(name)}</div><div class="reward-item-qty">x${g.quantity}</div></div></div>`;
            });
            html+='</div>';
        });
    }

    content.innerHTML=html;modal.style.display='flex';
    if(currentSession)currentSession.rewards_claimed=true;
    clearActivity();
    updateHuntingHUD();
}

// â”€â”€ BANNERS GLOBAIS DE PVP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function syncGlobalPvpEvents(){
    if(!userId)return false;
    let changed=false;
    try{
        const{data,error}=await supabase.rpc('get_hunt_pvp_events',{p_since_minutes:5});
        if(error||!data)return false;
        const seenKey=`hunt_pvp_seen_${userId}`;
        let seen;try{seen=new Set(JSON.parse(localStorage.getItem(seenKey)||'[]'));}catch{seen=new Set();}
        (data||[]).forEach(ev=>{
            if(seen.has(ev.id))return;
            seen.add(ev.id);changed=true;
            const regionLabel=`<span style="color:#8ff">${esc(ev.region_name)}</span>`;
            if(ev.attacker_won){
                const kTxt=ev.attacker_kills>0?`, eliminando um total de <span style="color:#ff8">${ev.attacker_kills}</span> hoje!`:'!';
                pushKillNotif(`<span style="color:#ff8">${esc(ev.attacker_name)}</span> acabou de eliminar <span style="color:#f88">${esc(ev.defender_name)}</span> em ${regionLabel}${kTxt}`);
            }else{
                const dkTxt=ev.defender_kills>0?`. <span style="color:#8ff">${esc(ev.defender_name)}</span> jÃ¡ eliminou <span style="color:#ff8">${ev.defender_kills}</span> hoje!`:'.';
                pushKillNotif(`<span style="color:#f88">${esc(ev.attacker_name)}</span> tentou atacar <span style="color:#ff8">${esc(ev.defender_name)}</span> em ${regionLabel} e perdeu${dkTxt}`);
            }
        });
        if(changed){try{localStorage.setItem(seenKey,JSON.stringify([...seen].slice(-200)));}catch{}}
    }catch(e){console.warn('[floresta] pvp events error',e);}
    return changed;
}

// â”€â”€ ADAPTIVE POLL SCHEDULER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _getBaseInterval(){
    const hasOthers=otherPlayers.some(p=>!p.is_eliminated&&
        (p.is_hunting||(p.pvp_only_entered_at&&new Date(p.pvp_only_entered_at)>new Date(Date.now()-15*60*1000))));
    if(isPvpOnly)              return POLL_BASE.pvp_only;
    if(isHunting&&hasOthers)   return POLL_BASE.hunting_with_others;
    if(isHunting&&!hasOthers)  return POLL_BASE.hunting_alone;
    if(!isHunting&&hasOthers)  return POLL_BASE.paused_with_others;
    return POLL_BASE.paused_alone;
}
function _getMaxInterval(){
    if(isPvpOnly)return POLL_MAX_3MIN;
    if(isHunting&&otherPlayers.some(p=>!p.is_eliminated))return POLL_MAX_3MIN;
    return POLL_MAX_5MIN;
}
function _resetPollInterval(){_currentPollMs=_getBaseInterval();}
function _stepBackoff(changed){
    if(changed){_currentPollMs=_getBaseInterval();}
    else{_currentPollMs=Math.min(_currentPollMs+POLL_STEP,_getMaxInterval());}
}

function scheduleNextSync(){
    clearTimeout(_syncTimeout);
    if(_inactivityPaused||document.visibilityState==='hidden')return;
    _syncTimeout=setTimeout(async()=>{
        const[playersChanged,pvpChanged]=await Promise.all([syncOtherPlayers(),syncGlobalPvpEvents()]);
        _stepBackoff(playersChanged||pvpChanged);
        scheduleNextSync();
    },_currentPollMs);
}
function stopAllPolling(){clearTimeout(_syncTimeout);_syncTimeout=null;}

// â”€â”€ PAGE VISIBILITY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('visibilitychange',()=>{
    if(document.visibilityState==='hidden'){stopAllPolling();}
    else if(!_inactivityPaused&&userId){
        // RelÃª inventÃ¡rio â€” pode ter mudado em outra aba (ex: compra no mercador).
        // Se o IDB retornar 0, consulta o servidor como fallback (garante que compras
        // no mercador aparecem sem precisar visitar o inventÃ¡rio).
        (async()=>{
            await initShieldFromCache();
            if(cachedShieldQty===0){
                try{
                    const{data}=await supabase.from('inventory_items')
                        .select('quantity')
                        .eq('player_id',userId)
                        .eq('item_id',SHIELD_ITEM_ID)
                        .is('equipped_slot',null);
                    const srvQty=(data||[]).reduce((s,i)=>s+(i.quantity||0),0);
                    if(srvQty>0){cachedShieldQty=srvQty;updateShieldBtn();}
                }catch{}
            }
        })();
        _currentPollMs=_getBaseInterval();
        Promise.all([syncOtherPlayers(),syncGlobalPvpEvents()]).then(()=>scheduleNextSync()).catch(()=>scheduleNextSync());
    }
});

// â”€â”€ INACTIVITY GUARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const _INACTIVITY_MS       = 3 * 60 * 1000;
const _INACTIVITY_CHECK_MS = 20_000;
function _resetActivity(){_lastActivityMs=Date.now();}
['touchstart','click','mousemove','keydown','scroll','pointerdown'].forEach(ev=>{
    document.addEventListener(ev,_resetActivity,{passive:true,capture:true});
});
function _startInactivityGuard(){
    clearInterval(_inactivityCheckId);
    _inactivityCheckId=setInterval(()=>{
        if(_inactivityPaused)return;
        if(Date.now()-_lastActivityMs>=_INACTIVITY_MS)_showInactivityModal();
    },_INACTIVITY_CHECK_MS);
}
function _showInactivityModal(){
    _inactivityPaused=true;stopAllPolling();
    const m=document.getElementById('inactivityModal');if(m)m.style.display='flex';
}

// â”€â”€ SYNC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// get_hunting_state faz UPDATE last_seen (heartbeat) + retorna estado completo.
// Retorna true se houve mudanÃ§a (para o backoff saber que deve resetar).
async function syncOtherPlayers(){
    if(!userId)return false;
    let changed=false;
    try{
        const{data,error}=await supabase.rpc('get_hunting_state',{p_player_id:userId,p_region_id:REGION_ID});
        if(error||!data)return false;
        const own=data.own_session||{};
        const newPlayers=data.other_players||[];

        // Detecta mudanÃ§a
        const newHash=newPlayers.map(p=>`${p.id}:${p.current_spot}:${p.is_hunting?1:0}:${p.is_eliminated?1:0}`).sort().join('|');
        if(newHash!==_lastPlayersHash){changed=true;_lastPlayersHash=newHash;}

        // Persiste jogadores no IDB owners (beneficia mines.js e outras pÃ¡ginas)
        const toSave=newPlayers.filter(p=>p.id&&p.name).map(p=>({id:p.id,name:p.name,avatar_url:p.avatar_url||''}));
        if(toSave.length){
            _idbSaveOwners(toSave).catch(()=>{});
            toSave.forEach(o=>{if(!_ownersMap[o.id]||changed)_ownersMap[o.id]={...(_ownersMap[o.id]||{}),...o};});
        }

        // Resolve guild names para todos os jogadores presentes (lazy, post-render)
        const guildIds=newPlayers.map(p=>_ownersMap[p.id]?.guild_id).filter(Boolean);
        if(guildIds.length)_resolveGuildNames([...new Set(guildIds)]).catch(()=>{});
        // Busca guild_id de jogadores que nÃ£o tÃªm no IDB (ex: nunca mineraram)
        const needsGuild=newPlayers.filter(p=>p.id&&(!_ownersMap[p.id]||!_ownersMap[p.id]?.guild_id)).map(p=>p.id);
        if(needsGuild.length)_fetchMissingGuildIds(needsGuild).catch(()=>{});

        // Banners de saÃ­da de spot
        otherPlayers.forEach(old=>{
            if(old.is_eliminated)return;
            const stillHere=newPlayers.find(np=>np.id===old.id);
            if(!stillHere&&old.is_hunting)
                pushKillNotif(`<span style="color:#ff8">${esc(old.name||_ownersMap[old.id]?.name||'?')}</span> deixou o spot em <span style="color:#8ff">${esc(REGION_NAME)}</span>.`);
        });
        otherPlayers=newPlayers;renderOtherPlayers(otherPlayers);

        // EliminaÃ§Ã£o detectada via own_session
        if(own.is_eliminated&&!isEliminationAcknowledged(currentSession?.hunt_date||own.hunt_date)){
            isHunting=false;isPvpOnly=false;stopLocalTimer();stopPvpOnlyTimer();
            clearTimeout(pvpOnlyExitTimer);
            removePlayerFromSpot();currentSpotId=null;updateHuntingHUD();
            document.getElementById('eliminatedByName').textContent=own.eliminated_by_name||'alguÃ©m';
            document.getElementById('eliminatedModal').style.display='flex';
        }

        // Atualiza escudo se mudou no servidor
        if(own.shield_until){
            const srv=new Date(own.shield_until);
            if(!shieldUntil||Math.abs(srv.getTime()-shieldUntil.getTime())>2000){shieldUntil=srv;if(isShieldActive())startShieldTimer();}
        }

        // Persiste snapshot no boot cache
        try{localStorage.setItem(HUNT_CACHE_KEY(),JSON.stringify({ts:Date.now(),data}));}catch{}

        // Resync do timer se o jogador nÃ£o estiver caÃ§ando â€” corrige drift de
        // sessÃµes pausadas/finalizadas em outro dispositivo ou aba
        if(!isHunting&&!isPvpOnly&&own.total_seconds!==undefined){
            const srvLeft=Math.max(0,DAILY_LIMIT-(own.total_seconds||0));
            if(Math.abs(srvLeft-localSecondsLeft)>5){localSecondsLeft=srvLeft;updateTimerDisplay();}
        }
    }catch(e){console.warn('[floresta] sync error',e);}
    return changed;
}

// â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function boot(){
    showLoading();
    createKillBannerUI();
    try{
        userId=await getUserId();if(!userId){location.href='index.html';return;}

        // â”€â”€ PrÃ©-carrega IDB owners (zero egress, melhora render imediato) â”€â”€
        _idbGetAllOwners().then(async map=>{
            _ownersMap=map;
            // Resolve guild names em batch para quem jÃ¡ estÃ¡ no IDB
            const gIds=[...new Set(Object.values(map).map(o=>o.guild_id).filter(Boolean))];
            if(gIds.length)_resolveGuildNames(gIds).catch(()=>{});
            // Garante que o prÃ³prio jogador estÃ¡ no mapa (para guild no prÃ³prio avatar)
            if(userId&&!_ownersMap[userId]?.guild_id){
                supabase.from('players').select('id,guild_id').eq('id',userId).single()
                    .then(({data})=>{
                        if(data?.guild_id){
                            if(!_ownersMap[userId])_ownersMap[userId]={id:userId};
                            _ownersMap[userId].guild_id=data.guild_id;
                            _idbSaveOwners([{id:userId,guild_id:data.guild_id}]).catch(()=>{});
                            _resolveGuildNames([data.guild_id]).then(()=>{
                                // Re-renderiza o prÃ³prio avatar com a guilda
                                if(currentSpotId)renderPlayerOnSpot(currentSpotId);
                            }).catch(()=>{});
                        }
                    }).catch(()=>{});
            }
        }).catch(()=>{});

        playerData=await getPlayerData();

        // Se ainda sem dados (primeirÃ­ssima sessÃ£o), tenta combat stats cache como last resort
        if(!playerData){
            try{
                const raw=localStorage.getItem(STATS_CACHE_KEY());
                if(raw){const p=JSON.parse(raw);if(p?.data?.name)playerData=p.data;}
            }catch{}
        }

        preload('normal');preload('critical');preload('evade');
        await initShieldFromCache();
        // Fallback servidor para o escudo: se IDB retornar 0 (ex: compra recente no mercador
        // que ainda nÃ£o propagou para o IDB desta aba), consulta o banco uma vez.
        if(cachedShieldQty===0){
            try{
                const{data}=await supabase.from('inventory_items')
                    .select('quantity')
                    .eq('player_id',userId)
                    .eq('item_id',SHIELD_ITEM_ID)
                    .is('equipped_slot',null);
                const srvQty=(data||[]).reduce((s,i)=>s+(i.quantity||0),0);
                if(srvQty>0){cachedShieldQty=srvQty;updateShieldBtn();}
            }catch{}
        }

        // Restaura dead state
        const savedAct=getActivity();
        if(savedAct?.pvp_dead&&savedAct?.dead_until&&savedAct.dead_until>Date.now()){
            deadUntil=savedAct.dead_until;
            const remaining=deadUntil-Date.now();
            clearTimeout(deadTimer);
            deadTimer=setTimeout(()=>{
                deadUntil=null;if(currentSpotId){isHunting=false;stopLocalTimer();removePlayerFromSpot();currentSpotId=null;}
                clearActivity();updateHuntingHUD();
            },remaining);
            _startDeadOverlay();
        }

        // Lazy cleanup
        (async()=>{try{await supabase.rpc('cleanup_old_hunting_sessions');}catch{}})();
        renderSpots();

        // â”€â”€ Boot cache (180s TTL) â€” restaura UI sem RPC apÃ³s reloads frequentes â”€â”€
        let huntData=null;
        let bootFromCache=false;
        try{
            const raw=localStorage.getItem(HUNT_CACHE_KEY());
            if(raw){const cached=JSON.parse(raw);if(cached?.ts&&(Date.now()-cached.ts)<HUNT_CACHE_TTL&&cached.data){huntData=cached.data;bootFromCache=true;}}
        }catch{}

        if(!bootFromCache){
            const{data,error}=await supabase.rpc('get_hunting_state',{p_player_id:userId,p_region_id:REGION_ID});
            if(error)throw error;
            huntData=data;
            try{localStorage.setItem(HUNT_CACHE_KEY(),JSON.stringify({ts:Date.now(),data:huntData}));}catch{}
        }

        currentSession=huntData?.own_session||null;
        otherPlayers=huntData?.other_players||[];

        // Salva outros jogadores no IDB (enrichment cross-page)
        const playersToCache=(otherPlayers||[]).filter(p=>p.id&&p.name).map(p=>({id:p.id,name:p.name,avatar_url:p.avatar_url||''}));
        if(playersToCache.length){
            _idbSaveOwners(playersToCache).catch(()=>{});
            playersToCache.forEach(o=>{_ownersMap[o.id]={...(_ownersMap[o.id]||{}),...o};});
            // Resolve guild names em batch (fire-and-forget, re-renderiza se necessÃ¡rio)
            const gIds=[...new Set(playersToCache.map(o=>_ownersMap[o.id]?.guild_id).filter(Boolean))];
            if(gIds.length)_resolveGuildNames(gIds).catch(()=>{});
        }

        if(currentSession){
            const srvTotal=currentSession.total_seconds||0;
            let localTotal=srvTotal;
            if(currentSession.is_hunting&&currentSession.hunt_started_at&&currentSession.current_region===REGION_ID){
                const elapsed=Math.floor((Date.now()-new Date(currentSession.hunt_started_at).getTime())/1000);
                localTotal=Math.min(DAILY_LIMIT,srvTotal+elapsed);
            }
            localSecondsLeft=Math.max(0,DAILY_LIMIT-localTotal);
            // currentSpotId sÃ³ Ã© restaurado se o jogador estiver ativamente caÃ§ando ou em PvP.
            // Caso contrÃ¡rio (ex: morreu no PvP e recarregou), spot fica null para permitir re-entrada.
            const _restoredSpot=(currentSession.current_region===REGION_ID)?currentSession.current_spot:null;
            if(currentSession.is_eliminated)currentSpotId=null;
            isHunting=currentSession.is_hunting
                &&currentSession.current_region===REGION_ID
                &&localSecondsLeft>0
                &&!currentSession.is_eliminated
                &&!currentSession.rewards_claimed;

            if(!isHunting&&currentSession.pvp_only_entered_at&&currentSession.current_region===REGION_ID&&!currentSession.is_eliminated){
                const pvpEnteredAt=new Date(currentSession.pvp_only_entered_at);
                const pvpElapsed=Math.floor((Date.now()-pvpEnteredAt.getTime())/1000);
                const pvpRemaining=900-pvpElapsed;
                if(pvpRemaining>0){isPvpOnly=true;pvpOnlySecondsLeft=pvpRemaining;}
            }

            // SÃ³ aplica currentSpotId se realmente vai usar o spot â€” evita "spot fantasma"
            // quando jogador estÃ¡ morto (is_hunting=false, pvp_only=null, mas current_spot ainda setado no DB)
            currentSpotId=(isHunting||isPvpOnly)?_restoredSpot:null;

            if(currentSession.shield_until){shieldUntil=new Date(currentSession.shield_until);if(isShieldActive())startShieldTimer();}
            if(isHunting&&currentSpotId){renderPlayerOnSpot(currentSpotId);startLocalTimer();amb.play().catch(()=>{});setActivityHunting(currentSpotId);}
            if(isPvpOnly&&currentSpotId){
                renderPlayerOnSpot(currentSpotId);
                startPvpOnlyTimer(false);
                // Restaura o setTimeout de saÃ­da com o tempo restante real (evita reset para 15 min apÃ³s kill)
                clearTimeout(pvpOnlyExitTimer);
                pvpOnlyExitTimer=setTimeout(exitPvpOnlyMode,pvpOnlySecondsLeft*1000);
            }

            if(localSecondsLeft<=0&&!currentSession.rewards_claimed&&srvTotal>=DAILY_LIMIT){isHunting=false;await onHuntComplete();}
            if(currentSession.is_eliminated&&!isEliminationAcknowledged(currentSession.hunt_date)){
                document.getElementById('eliminatedByName').textContent=currentSession.eliminated_by_name||'um inimigo';
                document.getElementById('eliminatedModal').style.display='flex';
            }
        }

        updateHuntingHUD();renderOtherPlayers(otherPlayers);
        await syncGlobalPvpEvents();

        // Inicia polling adaptativo + inactivity guard
        _currentPollMs=_getBaseInterval();
        scheduleNextSync();
        _startInactivityGuard();

    }catch(e){console.error('[floresta] boot error',e);await showAlert('Erro ao carregar. Recarregue a pÃ¡gina.');}
    finally{hideLoading();}
}

// â”€â”€ COMBAT LOOP (mob attack animation â€” apenas caÃ§a normal, nÃ£o pvp puro) â”€â”€â”€â”€â”€â”€

// Own-player loop state
let _combatLoopActive = false;
let _combatLoopTimeout = null;

// â”€â”€ Sound with controllable volume (uses GainNode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playSoundAt(name, volume){
    try{ if(audioCtx.state==='suspended') audioCtx.resume(); }catch{}
    const buf = audioBufs[name];
    if(!buf) return;
    try{
        const gain = audioCtx.createGain();
        gain.gain.value = volume;
        gain.connect(audioCtx.destination);
        const s = audioCtx.createBufferSource();
        s.buffer = buf;
        s.connect(gain);
        s.start(0);
        s.onended = ()=>{ try{ s.disconnect(); gain.disconnect(); }catch{} };
    }catch{}
}

// â”€â”€ Own-player loop (full volume) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startCombatLoop(){
    if(_combatLoopActive) return;
    _combatLoopActive = true;
    _combatLoopTimeout = setTimeout(()=>_combatTick_own(), 2800 + Math.random()*1800);
}

function stopCombatLoop(){
    _combatLoopActive = false;
    clearTimeout(_combatLoopTimeout);
    _combatLoopTimeout = null;
    const pw = document.querySelector('.player-avatar-wrapper');
    if(pw){
        pw.classList.remove('player-lunging');
        pw.style.transition = 'left 0.7s ease, top 0.7s ease, right 0.5s, bottom 0.5s';
        pw.style.right = '10px'; pw.style.bottom = '10px';
        pw.style.left = 'auto'; pw.style.top = 'auto';
    }
}

async function _combatTick_own(){
    if(!_combatLoopActive || !isHunting || isPvpOnly || !currentSpotId){ _combatLoopActive=false; return; }
    const spotEl = document.getElementById(`spot-${currentSpotId}`);
    const playerWrap = spotEl?.querySelector('.player-avatar-wrapper');
    if(!spotEl || !playerWrap){ _scheduleOwn(); return; }
    const spot = SPOTS.find(s=>s.id===currentSpotId);
    if(!spot){ _scheduleOwn(); return; }

    const done = await _runAttackSequence(playerWrap, spotEl, spot, null, ()=>_combatLoopActive && isHunting && !isPvpOnly);
    if(!done) return;
    _scheduleOwn();
}

function _scheduleOwn(){
    if(!_combatLoopActive) return;
    _combatLoopTimeout = setTimeout(()=>_combatTick_own(), 2500 + Math.random()*2500);
}

// â”€â”€ Other-players global combat interval â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _otherCombatInterval = null;

function startOtherCombatLoop(playerId, spotId){
    // No-op per-player: global interval handles everything
}
function stopOtherCombatLoop(playerId){
    // No-op per-player
}
function stopAllOtherCombatLoops(){
    clearInterval(_otherCombatInterval);
    _otherCombatInterval = null;
}

// Kick global interval whenever renderOtherPlayers runs
function _ensureOtherCombatInterval(){
    if(_otherCombatInterval) return;
    _otherCombatInterval = setInterval(_otherCombatGlobalTick, 1800 + Math.random()*1200);
}

// One tick: pick a random non-busy other-player-wrapper and run one attack
let _otherCombatBusy = new Set(); // player-ids currently mid-animation

async function _otherCombatGlobalTick(){
    // Collect all visible, non-eliminated, non-busy other-player wrappers
    const allWrappers = [...document.querySelectorAll('.other-player-wrapper')]
        .filter(w => !w.querySelector('.other-eliminated-label') && !_otherCombatBusy.has(w.dataset.playerId));

    if(allWrappers.length === 0) return;

    // Pick one at random
    const playerWrap = allWrappers[Math.floor(Math.random() * allWrappers.length)];
    const spotEl = playerWrap.closest('.hunt-spot');
    if(!spotEl) return;

    const spotId = spotEl.id.replace('spot-', '');
    const spot = SPOTS.find(s => s.id === spotId);
    if(!spot) return;

    const pid = playerWrap.dataset.playerId;
    _otherCombatBusy.add(pid);

    await _runAttackSequence(playerWrap, spotEl, spot, 0.10, () => !!playerWrap.parentElement);

    // Rest period before this player can be picked again (2.5â€“5s)
    setTimeout(() => _otherCombatBusy.delete(pid), 100 + Math.random() * 500);
}

// â”€â”€ Generic attack sequence (shared by own + others) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// soundVolume: null = full volume (own player), number = specific volume (others)
// isAlive: function returning bool â€” gates the await checkpoints
async function _runAttackSequence(playerWrap, spotEl, spot, soundVolume, isAlive){
    const isOwn = soundVolume === null; // own player uses null volume
    const mobs = [...spotEl.querySelectorAll('.mob-wrapper')].filter(m=>!m.classList.contains('mob-dying'));
    if(mobs.length === 0) return true;

    const targetMob = mobs[Math.floor(Math.random() * mobs.length)];
    const mobL = parseFloat(targetMob.style.left) || targetMob.offsetLeft;
    const mobT = parseFloat(targetMob.style.top)  || targetMob.offsetTop;
    const pW = 70, pH = 90;

    const rawLeft  = mobL - pW - 4 + (Math.random()*16 - 8);
    const rawTop   = mobT + (Math.random()*18 - 9);
    const destLeft = Math.max(4, Math.min(spot.width  - pW - 4, rawLeft));
    const destTop  = Math.max(4, Math.min(spot.height - pH - 4, rawTop));

    playerWrap.style.transition = 'left 0.55s cubic-bezier(0.22,1,0.36,1), top 0.55s cubic-bezier(0.22,1,0.36,1), right 0.1s, bottom 0.1s';
    playerWrap.style.right  = 'auto';
    playerWrap.style.bottom = 'auto';
    playerWrap.style.left   = destLeft + 'px';
    playerWrap.style.top    = destTop  + 'px';

    await _delay(580);
    if(!isAlive()) return false;

    // Lunge
    playerWrap.classList.remove('player-lunging');
    void playerWrap.offsetWidth;
    playerWrap.classList.add('player-lunging');
    setTimeout(()=>playerWrap.classList.remove('player-lunging'), 500);

    // Hit stats
    const isCrit  = Math.random() < 0.18;
    const isEvade = !isCrit && Math.random() < 0.10;
    const dmg     = isEvade ? 0 : Math.floor(isCrit ? 4000+Math.random()*4000 : 2000+Math.random()*2000);

    // Flash mob
    targetMob.classList.remove('mob-impact-flash');
    void targetMob.offsetWidth;
    targetMob.classList.add('mob-impact-flash');
    setTimeout(()=>targetMob.classList.remove('mob-impact-flash'), 320);

    // Damage number suppressed in spot animation â€” sounds and shake only
    // _showMobDmgNumber(targetMob, dmg, isCrit, isEvade);

    // Sound â€” own player uses full volume, others use 0.005
    const sndName = isEvade ? 'evade' : isCrit ? 'critical' : 'normal';
    if(soundVolume === null) playSound(sndName);
    else playSoundAt(sndName, soundVolume);

    // Shake mob avatar
    const mobAv = targetMob.querySelector('.mob-avatar');
    if(mobAv && !isEvade){
        mobAv.classList.remove('shake-animation');
        void mobAv.offsetWidth;
        mobAv.classList.add('shake-animation');
        setTimeout(()=>mobAv.classList.remove('shake-animation'), 400);
    }

    await _delay(750);
    if(!isAlive()) return false;

    // 40% chance of mob death
    if(!isEvade && !targetMob.classList.contains('mob-dying') && Math.random() < 0.40){
        _triggerMobDeath(targetMob, spot);
    }

    // Return to resting position â€” own player goes to fixed corner, others wander freely
    await _delay(300);
    if(!isAlive()) return false;

    let returnLeft, returnTop;
    if(isOwn){
        // Own player also wanders to a random position within the spot
        returnLeft = 10 + Math.random() * Math.max(10, spot.width  - pW - 20);
        returnTop  = 10 + Math.random() * Math.max(10, spot.height - pH - 20);
    } else {
        // Other players wander to a new random position within the spot
        returnLeft = 10 + Math.random() * Math.max(10, spot.width  - pW - 20);
        returnTop  = 10 + Math.random() * Math.max(10, spot.height - pH - 20);
    }
    playerWrap.style.transition = 'left 1.4s ease-in-out, top 1.4s ease-in-out';
    playerWrap.style.left = Math.max(4, Math.min(spot.width - pW - 4, returnLeft)) + 'px';
    playerWrap.style.top  = Math.max(4, Math.min(spot.height - pH - 4, returnTop)) + 'px';

    return true;
}

function _delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

function _showMobDmgNumber(mobEl, dmg, crit, evaded){
    const el = document.createElement('div');
    if(evaded){ el.textContent = 'Desviou'; el.className = 'evade-text'; }
    else { el.textContent = Number(dmg).toLocaleString(); el.className = crit ? 'crit-damage-number' : 'damage-number'; }
    mobEl.style.position = 'absolute';
    el.style.position = 'absolute';
    el.style.top  = '10px';
    el.style.left = '50%';
    el.style.transform = 'translateX(-50%)';
    el.style.zIndex = '20';
    el.style.pointerEvents = 'none';
    mobEl.appendChild(el);
    el.addEventListener('animationend', ()=>el.remove(), {once:true});
}

function _triggerMobDeath(mobEl, spot){
    if(mobEl.classList.contains('mob-dying') || mobEl.classList.contains('mob-respawning')) return;
    mobEl.classList.add('mob-dying');

    setTimeout(()=>{
        if(!mobEl.parentElement) return;
        const newL = 8 + Math.random() * Math.max(10, spot.width  - 80);
        const newT = 8 + Math.random() * Math.max(10, spot.height - 95);
        mobEl.style.transition = 'none';
        mobEl.style.left = newL + 'px';
        mobEl.style.top  = newT + 'px';
        mobEl.classList.remove('mob-dying');
        mobEl.classList.add('mob-respawning');
        void mobEl.offsetWidth;
        setTimeout(()=>{ mobEl.classList.remove('mob-respawning'); }, 800);
    }, 3000);
}

document.addEventListener('DOMContentLoaded',async()=>{
    enableMapInteraction();
    document.getElementById('pauseHuntBtn').addEventListener('click',handlePauseHunt);
    document.getElementById('activateShieldBtn').addEventListener('click',handleActivateShield);
    document.getElementById('tutorialBtn').addEventListener('click',()=>{document.getElementById('huntInfoModal').style.display='flex';});
    document.getElementById('huntInfoClose').addEventListener('click',()=>{document.getElementById('huntInfoModal').style.display='none';});
    document.getElementById('huntInfoModal').addEventListener('click',e=>{if(e.target===document.getElementById('huntInfoModal'))document.getElementById('huntInfoModal').style.display='none';});
    document.getElementById('eliminatedCloseBtn').addEventListener('click',()=>{
        document.getElementById('eliminatedModal').style.display='none';
        setEliminationAcknowledged(currentSession?.hunt_date); // grava ack aqui, nÃ£o ao mostrar
        isHunting=false;isPvpOnly=false;
        stopLocalTimer();stopPvpOnlyTimer();
        clearTimeout(pvpOnlyExitTimer);
        currentSpotId=null;
        removePlayerFromSpot();
        clearActivity();
        updateHuntingHUD();
    });
    document.getElementById('rewardsCloseBtn').addEventListener('click',()=>{document.getElementById('rewardsModal').style.display='none';});
    document.getElementById('inactivityOkBtn').addEventListener('click',()=>{location.reload();});
    await boot();
});
</script>

<!-- Modal de inatividade -->
<div id="inactivityModal" class="modal-container">
    <div class="modal-content">
        <h2>ğŸ‘‹ VocÃª estÃ¡ aÃ­?</h2>
        <p style="color:#cdc;font-size:.85em;line-height:1.6;">
            VocÃª nÃ£o precisa ficar nesta tela para <strong>continuar caÃ§ando</strong>. O tempo acumula automaticamente enquanto o spot estiver ativo.<br><br>
            Caso nÃ£o queira ser incomodado por outros jogadores, vocÃª pode comprar um <strong>ğŸ›¡ Escudo de CaÃ§a</strong> com o Mercador em alguma cidade!
        </p>
        <div class="modal-btn-row"><button id="inactivityOkBtn" class="modal-btn">Entendi</button></div>
    </div>
</div>

<div id="google_translate_element"></div>
<script src="auto_translate.js"></script>
<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
<script>
(function() {
    const style = document.createElement('style');

    style.innerHTML = `
        /* AnimaÃ§Ã£o de movimento (serve para ambos) */
        @keyframes shine {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        /* --- 1. ESTILO DOS NOBRES (Brilho Azul/Ouro - Intacto) --- */
        .shiny-icon {
            display: inline-block;
            background: linear-gradient(
                120deg, 
                #add8e6 0%, 
                #2b4bf2 30%, 
                #ffffff 40%, 
                #2b4bf2 50%, 
                #add8e6 80%
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            animation: shine 8s linear infinite;
            font-weight: 900;
            font-size: 1.1em;
            line-height: 1;
            vertical-align: middle;
            text-shadow: none !important;
        }

        /* --- 2. ESTILO DO JESTER (PalhaÃ§o + FumaÃ§a Marrom) --- */
        .jester-icon {
            display: inline-block;
            position: relative; 
            font-size: 1.2em;
            line-height: 1;
            vertical-align: middle;
            text-shadow: none !important;
            
            /* Garante que o emoji original seja visto normalmente */
            color: inherit !important;
            -webkit-text-fill-color: inherit !important;
        }

        /* A "FumaÃ§a/Sujeira" que passa por cima */
        .jester-icon::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
            
            /* Texto transparente para mostrar apenas o fundo (a fumaÃ§a) */
            color: transparent;
            -webkit-text-fill-color: transparent;
            
            /* Gradiente de FumaÃ§a: Transparente -> Marrom/Cinza -> Transparente */
            background: linear-gradient(
                120deg, 
                transparent 25%, 
                rgba(101, 67, 33, 0.4) 40%,   /* Marrom Escuro (Dark Brown) bem suave */
                rgba(139, 69, 19, 0.7) 50%,   /* Marrom Terra (Saddle Brown) mais forte */
                rgba(80, 80, 80, 0.5) 60%,    /* Cinza fuligem */
                transparent 75%
            );
            background-size: 200% auto;
            
            /* Recorta a fumaÃ§a no formato do emoji */
            -webkit-background-clip: text;
            background-clip: text;
            
            /* EFEITO DE GÃS: O Blur deixa o gradiente difuso parecendo fumaÃ§a */
            filter: blur(1.5px);
            
            /* AnimaÃ§Ã£o lenta arrastada */
            animation: shine 6s linear infinite;
        }
    `;
    document.head.appendChild(style);

    const targetIcons = /(\uD83D\uDC51|\u269C\uFE0F?|\uD83E\uDD21|\uD83D\uDEE1\uFE0F?|\uD83D\uDD30)/g;
    const jesterEmoji = '\uD83E\uDD21'; // ğŸ¤¡

    function styleTextNodes(node) {
        if (node.nodeType === 3 && targetIcons.test(node.nodeValue)) {
            const span = document.createElement('span');
            span.innerHTML = node.nodeValue.replace(targetIcons, (match) => {
                
                // Se for o PalhaÃ§o (Jester)
                if (match.indexOf(jesterEmoji) !== -1 || match === 'ğŸ¤¡') {
                    // Cria o span com o data-text para gerar a fumaÃ§a
                    return `<span class="jester-icon" data-text="${match}">${match}</span>`;
                }
                
                // Se for Nobre (Shiny normal)
                return `<span class="shiny-icon">${match}</span>`;
            });
            node.parentNode.replaceChild(span, node);
        } else if (node.nodeType === 1 && 
                   node.tagName !== 'SCRIPT' && 
                   node.tagName !== 'STYLE' && 
                   !node.classList.contains('shiny-icon') &&
                   !node.classList.contains('jester-icon')) {
            Array.from(node.childNodes).forEach(styleTextNodes);
        }
    }

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                styleTextNodes(node);
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
    styleTextNodes(document.body);

})();
</script>
</body>
</html>
